// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/sut63/team01/ent/annotation"
	"github.com/sut63/team01/ent/bill"
	"github.com/sut63/team01/ent/company"
	"github.com/sut63/team01/ent/dispensemedicine"
	"github.com/sut63/team01/ent/doctor"
	"github.com/sut63/team01/ent/drugallergy"
	"github.com/sut63/team01/ent/levelofdangerous"
	"github.com/sut63/team01/ent/medicine"
	"github.com/sut63/team01/ent/medicinetype"
	"github.com/sut63/team01/ent/order"
	"github.com/sut63/team01/ent/patientinfo"
	"github.com/sut63/team01/ent/payment"
	"github.com/sut63/team01/ent/pharmacist"
	"github.com/sut63/team01/ent/prescription"
	"github.com/sut63/team01/ent/unitofmedicine"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAnnotation       = "Annotation"
	TypeBill             = "Bill"
	TypeCompany          = "Company"
	TypeDispenseMedicine = "DispenseMedicine"
	TypeDoctor           = "Doctor"
	TypeDrugAllergy      = "DrugAllergy"
	TypeLevelOfDangerous = "LevelOfDangerous"
	TypeMedicine         = "Medicine"
	TypeMedicineType     = "MedicineType"
	TypeOrder            = "Order"
	TypePatientInfo      = "PatientInfo"
	TypePayment          = "Payment"
	TypePharmacist       = "Pharmacist"
	TypePrescription     = "Prescription"
	TypeUnitOfMedicine   = "UnitOfMedicine"
)

// AnnotationMutation represents an operation that mutate the Annotations
// nodes in the graph.
type AnnotationMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	messages                *string
	clearedFields           map[string]struct{}
	dispensemedicine        map[int]struct{}
	removeddispensemedicine map[int]struct{}
	done                    bool
	oldValue                func(context.Context) (*Annotation, error)
}

var _ ent.Mutation = (*AnnotationMutation)(nil)

// annotationOption allows to manage the mutation configuration using functional options.
type annotationOption func(*AnnotationMutation)

// newAnnotationMutation creates new mutation for $n.Name.
func newAnnotationMutation(c config, op Op, opts ...annotationOption) *AnnotationMutation {
	m := &AnnotationMutation{
		config:        c,
		op:            op,
		typ:           TypeAnnotation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAnnotationID sets the id field of the mutation.
func withAnnotationID(id int) annotationOption {
	return func(m *AnnotationMutation) {
		var (
			err   error
			once  sync.Once
			value *Annotation
		)
		m.oldValue = func(ctx context.Context) (*Annotation, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Annotation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAnnotation sets the old Annotation of the mutation.
func withAnnotation(node *Annotation) annotationOption {
	return func(m *AnnotationMutation) {
		m.oldValue = func(context.Context) (*Annotation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AnnotationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AnnotationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *AnnotationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetMessages sets the messages field.
func (m *AnnotationMutation) SetMessages(s string) {
	m.messages = &s
}

// Messages returns the messages value in the mutation.
func (m *AnnotationMutation) Messages() (r string, exists bool) {
	v := m.messages
	if v == nil {
		return
	}
	return *v, true
}

// OldMessages returns the old messages value of the Annotation.
// If the Annotation object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *AnnotationMutation) OldMessages(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMessages is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMessages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessages: %w", err)
	}
	return oldValue.Messages, nil
}

// ResetMessages reset all changes of the "messages" field.
func (m *AnnotationMutation) ResetMessages() {
	m.messages = nil
}

// AddDispensemedicineIDs adds the dispensemedicine edge to DispenseMedicine by ids.
func (m *AnnotationMutation) AddDispensemedicineIDs(ids ...int) {
	if m.dispensemedicine == nil {
		m.dispensemedicine = make(map[int]struct{})
	}
	for i := range ids {
		m.dispensemedicine[ids[i]] = struct{}{}
	}
}

// RemoveDispensemedicineIDs removes the dispensemedicine edge to DispenseMedicine by ids.
func (m *AnnotationMutation) RemoveDispensemedicineIDs(ids ...int) {
	if m.removeddispensemedicine == nil {
		m.removeddispensemedicine = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddispensemedicine[ids[i]] = struct{}{}
	}
}

// RemovedDispensemedicine returns the removed ids of dispensemedicine.
func (m *AnnotationMutation) RemovedDispensemedicineIDs() (ids []int) {
	for id := range m.removeddispensemedicine {
		ids = append(ids, id)
	}
	return
}

// DispensemedicineIDs returns the dispensemedicine ids in the mutation.
func (m *AnnotationMutation) DispensemedicineIDs() (ids []int) {
	for id := range m.dispensemedicine {
		ids = append(ids, id)
	}
	return
}

// ResetDispensemedicine reset all changes of the "dispensemedicine" edge.
func (m *AnnotationMutation) ResetDispensemedicine() {
	m.dispensemedicine = nil
	m.removeddispensemedicine = nil
}

// Op returns the operation name.
func (m *AnnotationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Annotation).
func (m *AnnotationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *AnnotationMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.messages != nil {
		fields = append(fields, annotation.FieldMessages)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *AnnotationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case annotation.FieldMessages:
		return m.Messages()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *AnnotationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case annotation.FieldMessages:
		return m.OldMessages(ctx)
	}
	return nil, fmt.Errorf("unknown Annotation field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AnnotationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case annotation.FieldMessages:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessages(v)
		return nil
	}
	return fmt.Errorf("unknown Annotation field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *AnnotationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *AnnotationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *AnnotationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Annotation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *AnnotationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *AnnotationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *AnnotationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Annotation nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *AnnotationMutation) ResetField(name string) error {
	switch name {
	case annotation.FieldMessages:
		m.ResetMessages()
		return nil
	}
	return fmt.Errorf("unknown Annotation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *AnnotationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.dispensemedicine != nil {
		edges = append(edges, annotation.EdgeDispensemedicine)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *AnnotationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case annotation.EdgeDispensemedicine:
		ids := make([]ent.Value, 0, len(m.dispensemedicine))
		for id := range m.dispensemedicine {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *AnnotationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddispensemedicine != nil {
		edges = append(edges, annotation.EdgeDispensemedicine)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *AnnotationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case annotation.EdgeDispensemedicine:
		ids := make([]ent.Value, 0, len(m.removeddispensemedicine))
		for id := range m.removeddispensemedicine {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *AnnotationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *AnnotationMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *AnnotationMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Annotation unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *AnnotationMutation) ResetEdge(name string) error {
	switch name {
	case annotation.EdgeDispensemedicine:
		m.ResetDispensemedicine()
		return nil
	}
	return fmt.Errorf("unknown Annotation edge %s", name)
}

// BillMutation represents an operation that mutate the Bills
// nodes in the graph.
type BillMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	amount                   *int
	addamount                *int
	annotation               *string
	clearedFields            map[string]struct{}
	pharmacists              *int
	clearedpharmacists       bool
	payments                 *int
	clearedpayments          bool
	dispenseMedicines        *int
	cleareddispenseMedicines bool
	done                     bool
	oldValue                 func(context.Context) (*Bill, error)
}

var _ ent.Mutation = (*BillMutation)(nil)

// billOption allows to manage the mutation configuration using functional options.
type billOption func(*BillMutation)

// newBillMutation creates new mutation for $n.Name.
func newBillMutation(c config, op Op, opts ...billOption) *BillMutation {
	m := &BillMutation{
		config:        c,
		op:            op,
		typ:           TypeBill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillID sets the id field of the mutation.
func withBillID(id int) billOption {
	return func(m *BillMutation) {
		var (
			err   error
			once  sync.Once
			value *Bill
		)
		m.oldValue = func(ctx context.Context) (*Bill, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBill sets the old Bill of the mutation.
func withBill(node *Bill) billOption {
	return func(m *BillMutation) {
		m.oldValue = func(context.Context) (*Bill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BillMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAmount sets the amount field.
func (m *BillMutation) SetAmount(i int) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the amount value in the mutation.
func (m *BillMutation) Amount() (r int, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old amount value of the Bill.
// If the Bill object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BillMutation) OldAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAmount is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to amount.
func (m *BillMutation) AddAmount(i int) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the amount field in this mutation.
func (m *BillMutation) AddedAmount() (r int, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount reset all changes of the "amount" field.
func (m *BillMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetAnnotation sets the annotation field.
func (m *BillMutation) SetAnnotation(s string) {
	m.annotation = &s
}

// Annotation returns the annotation value in the mutation.
func (m *BillMutation) Annotation() (r string, exists bool) {
	v := m.annotation
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnotation returns the old annotation value of the Bill.
// If the Bill object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BillMutation) OldAnnotation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAnnotation is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAnnotation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnotation: %w", err)
	}
	return oldValue.Annotation, nil
}

// ResetAnnotation reset all changes of the "annotation" field.
func (m *BillMutation) ResetAnnotation() {
	m.annotation = nil
}

// SetPharmacistsID sets the pharmacists edge to Pharmacist by id.
func (m *BillMutation) SetPharmacistsID(id int) {
	m.pharmacists = &id
}

// ClearPharmacists clears the pharmacists edge to Pharmacist.
func (m *BillMutation) ClearPharmacists() {
	m.clearedpharmacists = true
}

// PharmacistsCleared returns if the edge pharmacists was cleared.
func (m *BillMutation) PharmacistsCleared() bool {
	return m.clearedpharmacists
}

// PharmacistsID returns the pharmacists id in the mutation.
func (m *BillMutation) PharmacistsID() (id int, exists bool) {
	if m.pharmacists != nil {
		return *m.pharmacists, true
	}
	return
}

// PharmacistsIDs returns the pharmacists ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PharmacistsID instead. It exists only for internal usage by the builders.
func (m *BillMutation) PharmacistsIDs() (ids []int) {
	if id := m.pharmacists; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPharmacists reset all changes of the "pharmacists" edge.
func (m *BillMutation) ResetPharmacists() {
	m.pharmacists = nil
	m.clearedpharmacists = false
}

// SetPaymentsID sets the payments edge to Payment by id.
func (m *BillMutation) SetPaymentsID(id int) {
	m.payments = &id
}

// ClearPayments clears the payments edge to Payment.
func (m *BillMutation) ClearPayments() {
	m.clearedpayments = true
}

// PaymentsCleared returns if the edge payments was cleared.
func (m *BillMutation) PaymentsCleared() bool {
	return m.clearedpayments
}

// PaymentsID returns the payments id in the mutation.
func (m *BillMutation) PaymentsID() (id int, exists bool) {
	if m.payments != nil {
		return *m.payments, true
	}
	return
}

// PaymentsIDs returns the payments ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PaymentsID instead. It exists only for internal usage by the builders.
func (m *BillMutation) PaymentsIDs() (ids []int) {
	if id := m.payments; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPayments reset all changes of the "payments" edge.
func (m *BillMutation) ResetPayments() {
	m.payments = nil
	m.clearedpayments = false
}

// SetDispenseMedicinesID sets the dispenseMedicines edge to DispenseMedicine by id.
func (m *BillMutation) SetDispenseMedicinesID(id int) {
	m.dispenseMedicines = &id
}

// ClearDispenseMedicines clears the dispenseMedicines edge to DispenseMedicine.
func (m *BillMutation) ClearDispenseMedicines() {
	m.cleareddispenseMedicines = true
}

// DispenseMedicinesCleared returns if the edge dispenseMedicines was cleared.
func (m *BillMutation) DispenseMedicinesCleared() bool {
	return m.cleareddispenseMedicines
}

// DispenseMedicinesID returns the dispenseMedicines id in the mutation.
func (m *BillMutation) DispenseMedicinesID() (id int, exists bool) {
	if m.dispenseMedicines != nil {
		return *m.dispenseMedicines, true
	}
	return
}

// DispenseMedicinesIDs returns the dispenseMedicines ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DispenseMedicinesID instead. It exists only for internal usage by the builders.
func (m *BillMutation) DispenseMedicinesIDs() (ids []int) {
	if id := m.dispenseMedicines; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDispenseMedicines reset all changes of the "dispenseMedicines" edge.
func (m *BillMutation) ResetDispenseMedicines() {
	m.dispenseMedicines = nil
	m.cleareddispenseMedicines = false
}

// Op returns the operation name.
func (m *BillMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Bill).
func (m *BillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BillMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.amount != nil {
		fields = append(fields, bill.FieldAmount)
	}
	if m.annotation != nil {
		fields = append(fields, bill.FieldAnnotation)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bill.FieldAmount:
		return m.Amount()
	case bill.FieldAnnotation:
		return m.Annotation()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bill.FieldAmount:
		return m.OldAmount(ctx)
	case bill.FieldAnnotation:
		return m.OldAnnotation(ctx)
	}
	return nil, fmt.Errorf("unknown Bill field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bill.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case bill.FieldAnnotation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnotation(v)
		return nil
	}
	return fmt.Errorf("unknown Bill field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BillMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, bill.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BillMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bill.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BillMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bill.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Bill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BillMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Bill nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BillMutation) ResetField(name string) error {
	switch name {
	case bill.FieldAmount:
		m.ResetAmount()
		return nil
	case bill.FieldAnnotation:
		m.ResetAnnotation()
		return nil
	}
	return fmt.Errorf("unknown Bill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BillMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.pharmacists != nil {
		edges = append(edges, bill.EdgePharmacists)
	}
	if m.payments != nil {
		edges = append(edges, bill.EdgePayments)
	}
	if m.dispenseMedicines != nil {
		edges = append(edges, bill.EdgeDispenseMedicines)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bill.EdgePharmacists:
		if id := m.pharmacists; id != nil {
			return []ent.Value{*id}
		}
	case bill.EdgePayments:
		if id := m.payments; id != nil {
			return []ent.Value{*id}
		}
	case bill.EdgeDispenseMedicines:
		if id := m.dispenseMedicines; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BillMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedpharmacists {
		edges = append(edges, bill.EdgePharmacists)
	}
	if m.clearedpayments {
		edges = append(edges, bill.EdgePayments)
	}
	if m.cleareddispenseMedicines {
		edges = append(edges, bill.EdgeDispenseMedicines)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BillMutation) EdgeCleared(name string) bool {
	switch name {
	case bill.EdgePharmacists:
		return m.clearedpharmacists
	case bill.EdgePayments:
		return m.clearedpayments
	case bill.EdgeDispenseMedicines:
		return m.cleareddispenseMedicines
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BillMutation) ClearEdge(name string) error {
	switch name {
	case bill.EdgePharmacists:
		m.ClearPharmacists()
		return nil
	case bill.EdgePayments:
		m.ClearPayments()
		return nil
	case bill.EdgeDispenseMedicines:
		m.ClearDispenseMedicines()
		return nil
	}
	return fmt.Errorf("unknown Bill unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BillMutation) ResetEdge(name string) error {
	switch name {
	case bill.EdgePharmacists:
		m.ResetPharmacists()
		return nil
	case bill.EdgePayments:
		m.ResetPayments()
		return nil
	case bill.EdgeDispenseMedicines:
		m.ResetDispenseMedicines()
		return nil
	}
	return fmt.Errorf("unknown Bill edge %s", name)
}

// CompanyMutation represents an operation that mutate the Companies
// nodes in the graph.
type CompanyMutation struct {
	config
	op            Op
	typ           string
	id            *int
	companyname   *string
	clearedFields map[string]struct{}
	order         map[int]struct{}
	removedorder  map[int]struct{}
	done          bool
	oldValue      func(context.Context) (*Company, error)
}

var _ ent.Mutation = (*CompanyMutation)(nil)

// companyOption allows to manage the mutation configuration using functional options.
type companyOption func(*CompanyMutation)

// newCompanyMutation creates new mutation for $n.Name.
func newCompanyMutation(c config, op Op, opts ...companyOption) *CompanyMutation {
	m := &CompanyMutation{
		config:        c,
		op:            op,
		typ:           TypeCompany,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompanyID sets the id field of the mutation.
func withCompanyID(id int) companyOption {
	return func(m *CompanyMutation) {
		var (
			err   error
			once  sync.Once
			value *Company
		)
		m.oldValue = func(ctx context.Context) (*Company, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Company.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompany sets the old Company of the mutation.
func withCompany(node *Company) companyOption {
	return func(m *CompanyMutation) {
		m.oldValue = func(context.Context) (*Company, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompanyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompanyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CompanyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCompanyname sets the companyname field.
func (m *CompanyMutation) SetCompanyname(s string) {
	m.companyname = &s
}

// Companyname returns the companyname value in the mutation.
func (m *CompanyMutation) Companyname() (r string, exists bool) {
	v := m.companyname
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyname returns the old companyname value of the Company.
// If the Company object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CompanyMutation) OldCompanyname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCompanyname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCompanyname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyname: %w", err)
	}
	return oldValue.Companyname, nil
}

// ResetCompanyname reset all changes of the "companyname" field.
func (m *CompanyMutation) ResetCompanyname() {
	m.companyname = nil
}

// AddOrderIDs adds the order edge to Order by ids.
func (m *CompanyMutation) AddOrderIDs(ids ...int) {
	if m.order == nil {
		m.order = make(map[int]struct{})
	}
	for i := range ids {
		m.order[ids[i]] = struct{}{}
	}
}

// RemoveOrderIDs removes the order edge to Order by ids.
func (m *CompanyMutation) RemoveOrderIDs(ids ...int) {
	if m.removedorder == nil {
		m.removedorder = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorder[ids[i]] = struct{}{}
	}
}

// RemovedOrder returns the removed ids of order.
func (m *CompanyMutation) RemovedOrderIDs() (ids []int) {
	for id := range m.removedorder {
		ids = append(ids, id)
	}
	return
}

// OrderIDs returns the order ids in the mutation.
func (m *CompanyMutation) OrderIDs() (ids []int) {
	for id := range m.order {
		ids = append(ids, id)
	}
	return
}

// ResetOrder reset all changes of the "order" edge.
func (m *CompanyMutation) ResetOrder() {
	m.order = nil
	m.removedorder = nil
}

// Op returns the operation name.
func (m *CompanyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Company).
func (m *CompanyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CompanyMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.companyname != nil {
		fields = append(fields, company.FieldCompanyname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CompanyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case company.FieldCompanyname:
		return m.Companyname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CompanyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case company.FieldCompanyname:
		return m.OldCompanyname(ctx)
	}
	return nil, fmt.Errorf("unknown Company field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CompanyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case company.FieldCompanyname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyname(v)
		return nil
	}
	return fmt.Errorf("unknown Company field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CompanyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CompanyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CompanyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Company numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CompanyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CompanyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompanyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Company nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CompanyMutation) ResetField(name string) error {
	switch name {
	case company.FieldCompanyname:
		m.ResetCompanyname()
		return nil
	}
	return fmt.Errorf("unknown Company field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CompanyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.order != nil {
		edges = append(edges, company.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CompanyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case company.EdgeOrder:
		ids := make([]ent.Value, 0, len(m.order))
		for id := range m.order {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CompanyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedorder != nil {
		edges = append(edges, company.EdgeOrder)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CompanyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case company.EdgeOrder:
		ids := make([]ent.Value, 0, len(m.removedorder))
		for id := range m.removedorder {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CompanyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CompanyMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CompanyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Company unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CompanyMutation) ResetEdge(name string) error {
	switch name {
	case company.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown Company edge %s", name)
}

// DispenseMedicineMutation represents an operation that mutate the DispenseMedicines
// nodes in the graph.
type DispenseMedicineMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	datetime            *time.Time
	clearedFields       map[string]struct{}
	pharmacist          *int
	clearedpharmacist   bool
	annotation          *int
	clearedannotation   bool
	prescription        *int
	clearedprescription bool
	_Bills              *int
	cleared_Bills       bool
	done                bool
	oldValue            func(context.Context) (*DispenseMedicine, error)
}

var _ ent.Mutation = (*DispenseMedicineMutation)(nil)

// dispensemedicineOption allows to manage the mutation configuration using functional options.
type dispensemedicineOption func(*DispenseMedicineMutation)

// newDispenseMedicineMutation creates new mutation for $n.Name.
func newDispenseMedicineMutation(c config, op Op, opts ...dispensemedicineOption) *DispenseMedicineMutation {
	m := &DispenseMedicineMutation{
		config:        c,
		op:            op,
		typ:           TypeDispenseMedicine,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDispenseMedicineID sets the id field of the mutation.
func withDispenseMedicineID(id int) dispensemedicineOption {
	return func(m *DispenseMedicineMutation) {
		var (
			err   error
			once  sync.Once
			value *DispenseMedicine
		)
		m.oldValue = func(ctx context.Context) (*DispenseMedicine, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DispenseMedicine.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDispenseMedicine sets the old DispenseMedicine of the mutation.
func withDispenseMedicine(node *DispenseMedicine) dispensemedicineOption {
	return func(m *DispenseMedicineMutation) {
		m.oldValue = func(context.Context) (*DispenseMedicine, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DispenseMedicineMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DispenseMedicineMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DispenseMedicineMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDatetime sets the datetime field.
func (m *DispenseMedicineMutation) SetDatetime(t time.Time) {
	m.datetime = &t
}

// Datetime returns the datetime value in the mutation.
func (m *DispenseMedicineMutation) Datetime() (r time.Time, exists bool) {
	v := m.datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldDatetime returns the old datetime value of the DispenseMedicine.
// If the DispenseMedicine object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DispenseMedicineMutation) OldDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDatetime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatetime: %w", err)
	}
	return oldValue.Datetime, nil
}

// ResetDatetime reset all changes of the "datetime" field.
func (m *DispenseMedicineMutation) ResetDatetime() {
	m.datetime = nil
}

// SetPharmacistID sets the pharmacist edge to Pharmacist by id.
func (m *DispenseMedicineMutation) SetPharmacistID(id int) {
	m.pharmacist = &id
}

// ClearPharmacist clears the pharmacist edge to Pharmacist.
func (m *DispenseMedicineMutation) ClearPharmacist() {
	m.clearedpharmacist = true
}

// PharmacistCleared returns if the edge pharmacist was cleared.
func (m *DispenseMedicineMutation) PharmacistCleared() bool {
	return m.clearedpharmacist
}

// PharmacistID returns the pharmacist id in the mutation.
func (m *DispenseMedicineMutation) PharmacistID() (id int, exists bool) {
	if m.pharmacist != nil {
		return *m.pharmacist, true
	}
	return
}

// PharmacistIDs returns the pharmacist ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PharmacistID instead. It exists only for internal usage by the builders.
func (m *DispenseMedicineMutation) PharmacistIDs() (ids []int) {
	if id := m.pharmacist; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPharmacist reset all changes of the "pharmacist" edge.
func (m *DispenseMedicineMutation) ResetPharmacist() {
	m.pharmacist = nil
	m.clearedpharmacist = false
}

// SetAnnotationID sets the annotation edge to Annotation by id.
func (m *DispenseMedicineMutation) SetAnnotationID(id int) {
	m.annotation = &id
}

// ClearAnnotation clears the annotation edge to Annotation.
func (m *DispenseMedicineMutation) ClearAnnotation() {
	m.clearedannotation = true
}

// AnnotationCleared returns if the edge annotation was cleared.
func (m *DispenseMedicineMutation) AnnotationCleared() bool {
	return m.clearedannotation
}

// AnnotationID returns the annotation id in the mutation.
func (m *DispenseMedicineMutation) AnnotationID() (id int, exists bool) {
	if m.annotation != nil {
		return *m.annotation, true
	}
	return
}

// AnnotationIDs returns the annotation ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// AnnotationID instead. It exists only for internal usage by the builders.
func (m *DispenseMedicineMutation) AnnotationIDs() (ids []int) {
	if id := m.annotation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAnnotation reset all changes of the "annotation" edge.
func (m *DispenseMedicineMutation) ResetAnnotation() {
	m.annotation = nil
	m.clearedannotation = false
}

// SetPrescriptionID sets the prescription edge to Prescription by id.
func (m *DispenseMedicineMutation) SetPrescriptionID(id int) {
	m.prescription = &id
}

// ClearPrescription clears the prescription edge to Prescription.
func (m *DispenseMedicineMutation) ClearPrescription() {
	m.clearedprescription = true
}

// PrescriptionCleared returns if the edge prescription was cleared.
func (m *DispenseMedicineMutation) PrescriptionCleared() bool {
	return m.clearedprescription
}

// PrescriptionID returns the prescription id in the mutation.
func (m *DispenseMedicineMutation) PrescriptionID() (id int, exists bool) {
	if m.prescription != nil {
		return *m.prescription, true
	}
	return
}

// PrescriptionIDs returns the prescription ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PrescriptionID instead. It exists only for internal usage by the builders.
func (m *DispenseMedicineMutation) PrescriptionIDs() (ids []int) {
	if id := m.prescription; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrescription reset all changes of the "prescription" edge.
func (m *DispenseMedicineMutation) ResetPrescription() {
	m.prescription = nil
	m.clearedprescription = false
}

// SetBillsID sets the Bills edge to Bill by id.
func (m *DispenseMedicineMutation) SetBillsID(id int) {
	m._Bills = &id
}

// ClearBills clears the Bills edge to Bill.
func (m *DispenseMedicineMutation) ClearBills() {
	m.cleared_Bills = true
}

// BillsCleared returns if the edge Bills was cleared.
func (m *DispenseMedicineMutation) BillsCleared() bool {
	return m.cleared_Bills
}

// BillsID returns the Bills id in the mutation.
func (m *DispenseMedicineMutation) BillsID() (id int, exists bool) {
	if m._Bills != nil {
		return *m._Bills, true
	}
	return
}

// BillsIDs returns the Bills ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// BillsID instead. It exists only for internal usage by the builders.
func (m *DispenseMedicineMutation) BillsIDs() (ids []int) {
	if id := m._Bills; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBills reset all changes of the "Bills" edge.
func (m *DispenseMedicineMutation) ResetBills() {
	m._Bills = nil
	m.cleared_Bills = false
}

// Op returns the operation name.
func (m *DispenseMedicineMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DispenseMedicine).
func (m *DispenseMedicineMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DispenseMedicineMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.datetime != nil {
		fields = append(fields, dispensemedicine.FieldDatetime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DispenseMedicineMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dispensemedicine.FieldDatetime:
		return m.Datetime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DispenseMedicineMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dispensemedicine.FieldDatetime:
		return m.OldDatetime(ctx)
	}
	return nil, fmt.Errorf("unknown DispenseMedicine field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DispenseMedicineMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dispensemedicine.FieldDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatetime(v)
		return nil
	}
	return fmt.Errorf("unknown DispenseMedicine field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DispenseMedicineMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DispenseMedicineMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DispenseMedicineMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DispenseMedicine numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DispenseMedicineMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DispenseMedicineMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DispenseMedicineMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DispenseMedicine nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DispenseMedicineMutation) ResetField(name string) error {
	switch name {
	case dispensemedicine.FieldDatetime:
		m.ResetDatetime()
		return nil
	}
	return fmt.Errorf("unknown DispenseMedicine field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DispenseMedicineMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.pharmacist != nil {
		edges = append(edges, dispensemedicine.EdgePharmacist)
	}
	if m.annotation != nil {
		edges = append(edges, dispensemedicine.EdgeAnnotation)
	}
	if m.prescription != nil {
		edges = append(edges, dispensemedicine.EdgePrescription)
	}
	if m._Bills != nil {
		edges = append(edges, dispensemedicine.EdgeBills)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DispenseMedicineMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dispensemedicine.EdgePharmacist:
		if id := m.pharmacist; id != nil {
			return []ent.Value{*id}
		}
	case dispensemedicine.EdgeAnnotation:
		if id := m.annotation; id != nil {
			return []ent.Value{*id}
		}
	case dispensemedicine.EdgePrescription:
		if id := m.prescription; id != nil {
			return []ent.Value{*id}
		}
	case dispensemedicine.EdgeBills:
		if id := m._Bills; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DispenseMedicineMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DispenseMedicineMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DispenseMedicineMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedpharmacist {
		edges = append(edges, dispensemedicine.EdgePharmacist)
	}
	if m.clearedannotation {
		edges = append(edges, dispensemedicine.EdgeAnnotation)
	}
	if m.clearedprescription {
		edges = append(edges, dispensemedicine.EdgePrescription)
	}
	if m.cleared_Bills {
		edges = append(edges, dispensemedicine.EdgeBills)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DispenseMedicineMutation) EdgeCleared(name string) bool {
	switch name {
	case dispensemedicine.EdgePharmacist:
		return m.clearedpharmacist
	case dispensemedicine.EdgeAnnotation:
		return m.clearedannotation
	case dispensemedicine.EdgePrescription:
		return m.clearedprescription
	case dispensemedicine.EdgeBills:
		return m.cleared_Bills
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DispenseMedicineMutation) ClearEdge(name string) error {
	switch name {
	case dispensemedicine.EdgePharmacist:
		m.ClearPharmacist()
		return nil
	case dispensemedicine.EdgeAnnotation:
		m.ClearAnnotation()
		return nil
	case dispensemedicine.EdgePrescription:
		m.ClearPrescription()
		return nil
	case dispensemedicine.EdgeBills:
		m.ClearBills()
		return nil
	}
	return fmt.Errorf("unknown DispenseMedicine unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DispenseMedicineMutation) ResetEdge(name string) error {
	switch name {
	case dispensemedicine.EdgePharmacist:
		m.ResetPharmacist()
		return nil
	case dispensemedicine.EdgeAnnotation:
		m.ResetAnnotation()
		return nil
	case dispensemedicine.EdgePrescription:
		m.ResetPrescription()
		return nil
	case dispensemedicine.EdgeBills:
		m.ResetBills()
		return nil
	}
	return fmt.Errorf("unknown DispenseMedicine edge %s", name)
}

// DoctorMutation represents an operation that mutate the Doctors
// nodes in the graph.
type DoctorMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	email                     *string
	password                  *string
	name                      *string
	clearedFields             map[string]struct{}
	doctorprescription        map[int]struct{}
	removeddoctorprescription map[int]struct{}
	done                      bool
	oldValue                  func(context.Context) (*Doctor, error)
}

var _ ent.Mutation = (*DoctorMutation)(nil)

// doctorOption allows to manage the mutation configuration using functional options.
type doctorOption func(*DoctorMutation)

// newDoctorMutation creates new mutation for $n.Name.
func newDoctorMutation(c config, op Op, opts ...doctorOption) *DoctorMutation {
	m := &DoctorMutation{
		config:        c,
		op:            op,
		typ:           TypeDoctor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDoctorID sets the id field of the mutation.
func withDoctorID(id int) doctorOption {
	return func(m *DoctorMutation) {
		var (
			err   error
			once  sync.Once
			value *Doctor
		)
		m.oldValue = func(ctx context.Context) (*Doctor, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Doctor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDoctor sets the old Doctor of the mutation.
func withDoctor(node *Doctor) doctorOption {
	return func(m *DoctorMutation) {
		m.oldValue = func(context.Context) (*Doctor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DoctorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DoctorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DoctorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEmail sets the email field.
func (m *DoctorMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the email value in the mutation.
func (m *DoctorMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old email value of the Doctor.
// If the Doctor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DoctorMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail reset all changes of the "email" field.
func (m *DoctorMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the password field.
func (m *DoctorMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the password value in the mutation.
func (m *DoctorMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old password value of the Doctor.
// If the Doctor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DoctorMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword reset all changes of the "password" field.
func (m *DoctorMutation) ResetPassword() {
	m.password = nil
}

// SetName sets the name field.
func (m *DoctorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *DoctorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Doctor.
// If the Doctor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DoctorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *DoctorMutation) ResetName() {
	m.name = nil
}

// AddDoctorprescriptionIDs adds the doctorprescription edge to Prescription by ids.
func (m *DoctorMutation) AddDoctorprescriptionIDs(ids ...int) {
	if m.doctorprescription == nil {
		m.doctorprescription = make(map[int]struct{})
	}
	for i := range ids {
		m.doctorprescription[ids[i]] = struct{}{}
	}
}

// RemoveDoctorprescriptionIDs removes the doctorprescription edge to Prescription by ids.
func (m *DoctorMutation) RemoveDoctorprescriptionIDs(ids ...int) {
	if m.removeddoctorprescription == nil {
		m.removeddoctorprescription = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddoctorprescription[ids[i]] = struct{}{}
	}
}

// RemovedDoctorprescription returns the removed ids of doctorprescription.
func (m *DoctorMutation) RemovedDoctorprescriptionIDs() (ids []int) {
	for id := range m.removeddoctorprescription {
		ids = append(ids, id)
	}
	return
}

// DoctorprescriptionIDs returns the doctorprescription ids in the mutation.
func (m *DoctorMutation) DoctorprescriptionIDs() (ids []int) {
	for id := range m.doctorprescription {
		ids = append(ids, id)
	}
	return
}

// ResetDoctorprescription reset all changes of the "doctorprescription" edge.
func (m *DoctorMutation) ResetDoctorprescription() {
	m.doctorprescription = nil
	m.removeddoctorprescription = nil
}

// Op returns the operation name.
func (m *DoctorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Doctor).
func (m *DoctorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DoctorMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.email != nil {
		fields = append(fields, doctor.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, doctor.FieldPassword)
	}
	if m.name != nil {
		fields = append(fields, doctor.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DoctorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case doctor.FieldEmail:
		return m.Email()
	case doctor.FieldPassword:
		return m.Password()
	case doctor.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DoctorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case doctor.FieldEmail:
		return m.OldEmail(ctx)
	case doctor.FieldPassword:
		return m.OldPassword(ctx)
	case doctor.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Doctor field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DoctorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case doctor.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case doctor.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case doctor.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Doctor field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DoctorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DoctorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DoctorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Doctor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DoctorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DoctorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DoctorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Doctor nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DoctorMutation) ResetField(name string) error {
	switch name {
	case doctor.FieldEmail:
		m.ResetEmail()
		return nil
	case doctor.FieldPassword:
		m.ResetPassword()
		return nil
	case doctor.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Doctor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DoctorMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.doctorprescription != nil {
		edges = append(edges, doctor.EdgeDoctorprescription)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DoctorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case doctor.EdgeDoctorprescription:
		ids := make([]ent.Value, 0, len(m.doctorprescription))
		for id := range m.doctorprescription {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DoctorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddoctorprescription != nil {
		edges = append(edges, doctor.EdgeDoctorprescription)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DoctorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case doctor.EdgeDoctorprescription:
		ids := make([]ent.Value, 0, len(m.removeddoctorprescription))
		for id := range m.removeddoctorprescription {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DoctorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DoctorMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DoctorMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Doctor unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DoctorMutation) ResetEdge(name string) error {
	switch name {
	case doctor.EdgeDoctorprescription:
		m.ResetDoctorprescription()
		return nil
	}
	return fmt.Errorf("unknown Doctor edge %s", name)
}

// DrugAllergyMutation represents an operation that mutate the DrugAllergies
// nodes in the graph.
type DrugAllergyMutation struct {
	config
	op                Op
	typ               string
	id                *int
	dateTime          *time.Time
	clearedFields     map[string]struct{}
	patient           *int
	clearedpatient    bool
	medicine          *int
	clearedmedicine   bool
	pharmacist        *int
	clearedpharmacist bool
	done              bool
	oldValue          func(context.Context) (*DrugAllergy, error)
}

var _ ent.Mutation = (*DrugAllergyMutation)(nil)

// drugallergyOption allows to manage the mutation configuration using functional options.
type drugallergyOption func(*DrugAllergyMutation)

// newDrugAllergyMutation creates new mutation for $n.Name.
func newDrugAllergyMutation(c config, op Op, opts ...drugallergyOption) *DrugAllergyMutation {
	m := &DrugAllergyMutation{
		config:        c,
		op:            op,
		typ:           TypeDrugAllergy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDrugAllergyID sets the id field of the mutation.
func withDrugAllergyID(id int) drugallergyOption {
	return func(m *DrugAllergyMutation) {
		var (
			err   error
			once  sync.Once
			value *DrugAllergy
		)
		m.oldValue = func(ctx context.Context) (*DrugAllergy, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DrugAllergy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDrugAllergy sets the old DrugAllergy of the mutation.
func withDrugAllergy(node *DrugAllergy) drugallergyOption {
	return func(m *DrugAllergyMutation) {
		m.oldValue = func(context.Context) (*DrugAllergy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DrugAllergyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DrugAllergyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DrugAllergyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDateTime sets the dateTime field.
func (m *DrugAllergyMutation) SetDateTime(t time.Time) {
	m.dateTime = &t
}

// DateTime returns the dateTime value in the mutation.
func (m *DrugAllergyMutation) DateTime() (r time.Time, exists bool) {
	v := m.dateTime
	if v == nil {
		return
	}
	return *v, true
}

// OldDateTime returns the old dateTime value of the DrugAllergy.
// If the DrugAllergy object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DrugAllergyMutation) OldDateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateTime: %w", err)
	}
	return oldValue.DateTime, nil
}

// ResetDateTime reset all changes of the "dateTime" field.
func (m *DrugAllergyMutation) ResetDateTime() {
	m.dateTime = nil
}

// SetPatientID sets the patient edge to PatientInfo by id.
func (m *DrugAllergyMutation) SetPatientID(id int) {
	m.patient = &id
}

// ClearPatient clears the patient edge to PatientInfo.
func (m *DrugAllergyMutation) ClearPatient() {
	m.clearedpatient = true
}

// PatientCleared returns if the edge patient was cleared.
func (m *DrugAllergyMutation) PatientCleared() bool {
	return m.clearedpatient
}

// PatientID returns the patient id in the mutation.
func (m *DrugAllergyMutation) PatientID() (id int, exists bool) {
	if m.patient != nil {
		return *m.patient, true
	}
	return
}

// PatientIDs returns the patient ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PatientID instead. It exists only for internal usage by the builders.
func (m *DrugAllergyMutation) PatientIDs() (ids []int) {
	if id := m.patient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatient reset all changes of the "patient" edge.
func (m *DrugAllergyMutation) ResetPatient() {
	m.patient = nil
	m.clearedpatient = false
}

// SetMedicineID sets the medicine edge to Medicine by id.
func (m *DrugAllergyMutation) SetMedicineID(id int) {
	m.medicine = &id
}

// ClearMedicine clears the medicine edge to Medicine.
func (m *DrugAllergyMutation) ClearMedicine() {
	m.clearedmedicine = true
}

// MedicineCleared returns if the edge medicine was cleared.
func (m *DrugAllergyMutation) MedicineCleared() bool {
	return m.clearedmedicine
}

// MedicineID returns the medicine id in the mutation.
func (m *DrugAllergyMutation) MedicineID() (id int, exists bool) {
	if m.medicine != nil {
		return *m.medicine, true
	}
	return
}

// MedicineIDs returns the medicine ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// MedicineID instead. It exists only for internal usage by the builders.
func (m *DrugAllergyMutation) MedicineIDs() (ids []int) {
	if id := m.medicine; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMedicine reset all changes of the "medicine" edge.
func (m *DrugAllergyMutation) ResetMedicine() {
	m.medicine = nil
	m.clearedmedicine = false
}

// SetPharmacistID sets the pharmacist edge to Pharmacist by id.
func (m *DrugAllergyMutation) SetPharmacistID(id int) {
	m.pharmacist = &id
}

// ClearPharmacist clears the pharmacist edge to Pharmacist.
func (m *DrugAllergyMutation) ClearPharmacist() {
	m.clearedpharmacist = true
}

// PharmacistCleared returns if the edge pharmacist was cleared.
func (m *DrugAllergyMutation) PharmacistCleared() bool {
	return m.clearedpharmacist
}

// PharmacistID returns the pharmacist id in the mutation.
func (m *DrugAllergyMutation) PharmacistID() (id int, exists bool) {
	if m.pharmacist != nil {
		return *m.pharmacist, true
	}
	return
}

// PharmacistIDs returns the pharmacist ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PharmacistID instead. It exists only for internal usage by the builders.
func (m *DrugAllergyMutation) PharmacistIDs() (ids []int) {
	if id := m.pharmacist; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPharmacist reset all changes of the "pharmacist" edge.
func (m *DrugAllergyMutation) ResetPharmacist() {
	m.pharmacist = nil
	m.clearedpharmacist = false
}

// Op returns the operation name.
func (m *DrugAllergyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DrugAllergy).
func (m *DrugAllergyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DrugAllergyMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.dateTime != nil {
		fields = append(fields, drugallergy.FieldDateTime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DrugAllergyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case drugallergy.FieldDateTime:
		return m.DateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DrugAllergyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case drugallergy.FieldDateTime:
		return m.OldDateTime(ctx)
	}
	return nil, fmt.Errorf("unknown DrugAllergy field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DrugAllergyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case drugallergy.FieldDateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateTime(v)
		return nil
	}
	return fmt.Errorf("unknown DrugAllergy field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DrugAllergyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DrugAllergyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DrugAllergyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DrugAllergy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DrugAllergyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DrugAllergyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DrugAllergyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DrugAllergy nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DrugAllergyMutation) ResetField(name string) error {
	switch name {
	case drugallergy.FieldDateTime:
		m.ResetDateTime()
		return nil
	}
	return fmt.Errorf("unknown DrugAllergy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DrugAllergyMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.patient != nil {
		edges = append(edges, drugallergy.EdgePatient)
	}
	if m.medicine != nil {
		edges = append(edges, drugallergy.EdgeMedicine)
	}
	if m.pharmacist != nil {
		edges = append(edges, drugallergy.EdgePharmacist)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DrugAllergyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case drugallergy.EdgePatient:
		if id := m.patient; id != nil {
			return []ent.Value{*id}
		}
	case drugallergy.EdgeMedicine:
		if id := m.medicine; id != nil {
			return []ent.Value{*id}
		}
	case drugallergy.EdgePharmacist:
		if id := m.pharmacist; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DrugAllergyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DrugAllergyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DrugAllergyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedpatient {
		edges = append(edges, drugallergy.EdgePatient)
	}
	if m.clearedmedicine {
		edges = append(edges, drugallergy.EdgeMedicine)
	}
	if m.clearedpharmacist {
		edges = append(edges, drugallergy.EdgePharmacist)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DrugAllergyMutation) EdgeCleared(name string) bool {
	switch name {
	case drugallergy.EdgePatient:
		return m.clearedpatient
	case drugallergy.EdgeMedicine:
		return m.clearedmedicine
	case drugallergy.EdgePharmacist:
		return m.clearedpharmacist
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DrugAllergyMutation) ClearEdge(name string) error {
	switch name {
	case drugallergy.EdgePatient:
		m.ClearPatient()
		return nil
	case drugallergy.EdgeMedicine:
		m.ClearMedicine()
		return nil
	case drugallergy.EdgePharmacist:
		m.ClearPharmacist()
		return nil
	}
	return fmt.Errorf("unknown DrugAllergy unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DrugAllergyMutation) ResetEdge(name string) error {
	switch name {
	case drugallergy.EdgePatient:
		m.ResetPatient()
		return nil
	case drugallergy.EdgeMedicine:
		m.ResetMedicine()
		return nil
	case drugallergy.EdgePharmacist:
		m.ResetPharmacist()
		return nil
	}
	return fmt.Errorf("unknown DrugAllergy edge %s", name)
}

// LevelOfDangerousMutation represents an operation that mutate the LevelOfDangerousSlice
// nodes in the graph.
type LevelOfDangerousMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	clearedFields    map[string]struct{}
	_Medicine        map[int]struct{}
	removed_Medicine map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*LevelOfDangerous, error)
}

var _ ent.Mutation = (*LevelOfDangerousMutation)(nil)

// levelofdangerousOption allows to manage the mutation configuration using functional options.
type levelofdangerousOption func(*LevelOfDangerousMutation)

// newLevelOfDangerousMutation creates new mutation for $n.Name.
func newLevelOfDangerousMutation(c config, op Op, opts ...levelofdangerousOption) *LevelOfDangerousMutation {
	m := &LevelOfDangerousMutation{
		config:        c,
		op:            op,
		typ:           TypeLevelOfDangerous,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLevelOfDangerousID sets the id field of the mutation.
func withLevelOfDangerousID(id int) levelofdangerousOption {
	return func(m *LevelOfDangerousMutation) {
		var (
			err   error
			once  sync.Once
			value *LevelOfDangerous
		)
		m.oldValue = func(ctx context.Context) (*LevelOfDangerous, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LevelOfDangerous.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLevelOfDangerous sets the old LevelOfDangerous of the mutation.
func withLevelOfDangerous(node *LevelOfDangerous) levelofdangerousOption {
	return func(m *LevelOfDangerousMutation) {
		m.oldValue = func(context.Context) (*LevelOfDangerous, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LevelOfDangerousMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LevelOfDangerousMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *LevelOfDangerousMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *LevelOfDangerousMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *LevelOfDangerousMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the LevelOfDangerous.
// If the LevelOfDangerous object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *LevelOfDangerousMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *LevelOfDangerousMutation) ResetName() {
	m.name = nil
}

// AddMedicineIDs adds the Medicine edge to Medicine by ids.
func (m *LevelOfDangerousMutation) AddMedicineIDs(ids ...int) {
	if m._Medicine == nil {
		m._Medicine = make(map[int]struct{})
	}
	for i := range ids {
		m._Medicine[ids[i]] = struct{}{}
	}
}

// RemoveMedicineIDs removes the Medicine edge to Medicine by ids.
func (m *LevelOfDangerousMutation) RemoveMedicineIDs(ids ...int) {
	if m.removed_Medicine == nil {
		m.removed_Medicine = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_Medicine[ids[i]] = struct{}{}
	}
}

// RemovedMedicine returns the removed ids of Medicine.
func (m *LevelOfDangerousMutation) RemovedMedicineIDs() (ids []int) {
	for id := range m.removed_Medicine {
		ids = append(ids, id)
	}
	return
}

// MedicineIDs returns the Medicine ids in the mutation.
func (m *LevelOfDangerousMutation) MedicineIDs() (ids []int) {
	for id := range m._Medicine {
		ids = append(ids, id)
	}
	return
}

// ResetMedicine reset all changes of the "Medicine" edge.
func (m *LevelOfDangerousMutation) ResetMedicine() {
	m._Medicine = nil
	m.removed_Medicine = nil
}

// Op returns the operation name.
func (m *LevelOfDangerousMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (LevelOfDangerous).
func (m *LevelOfDangerousMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *LevelOfDangerousMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, levelofdangerous.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *LevelOfDangerousMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case levelofdangerous.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *LevelOfDangerousMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case levelofdangerous.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown LevelOfDangerous field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *LevelOfDangerousMutation) SetField(name string, value ent.Value) error {
	switch name {
	case levelofdangerous.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown LevelOfDangerous field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *LevelOfDangerousMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *LevelOfDangerousMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *LevelOfDangerousMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LevelOfDangerous numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *LevelOfDangerousMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *LevelOfDangerousMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *LevelOfDangerousMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LevelOfDangerous nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *LevelOfDangerousMutation) ResetField(name string) error {
	switch name {
	case levelofdangerous.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown LevelOfDangerous field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *LevelOfDangerousMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Medicine != nil {
		edges = append(edges, levelofdangerous.EdgeMedicine)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *LevelOfDangerousMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case levelofdangerous.EdgeMedicine:
		ids := make([]ent.Value, 0, len(m._Medicine))
		for id := range m._Medicine {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *LevelOfDangerousMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_Medicine != nil {
		edges = append(edges, levelofdangerous.EdgeMedicine)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *LevelOfDangerousMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case levelofdangerous.EdgeMedicine:
		ids := make([]ent.Value, 0, len(m.removed_Medicine))
		for id := range m.removed_Medicine {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *LevelOfDangerousMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *LevelOfDangerousMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *LevelOfDangerousMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown LevelOfDangerous unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *LevelOfDangerousMutation) ResetEdge(name string) error {
	switch name {
	case levelofdangerous.EdgeMedicine:
		m.ResetMedicine()
		return nil
	}
	return fmt.Errorf("unknown LevelOfDangerous edge %s", name)
}

// MedicineMutation represents an operation that mutate the Medicines
// nodes in the graph.
type MedicineMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	name                       *string
	serial                     *string
	brand                      *string
	amount                     *int
	addamount                  *int
	price                      *float64
	addprice                   *float64
	howtouse                   *string
	clearedFields              map[string]struct{}
	_LevelOfDangerous          *int
	cleared_LevelOfDangerous   bool
	_MedicineType              *int
	cleared_MedicineType       bool
	_UnitOfMedicine            *int
	cleared_UnitOfMedicine     bool
	drugallergys               map[int]struct{}
	removeddrugallergys        map[int]struct{}
	medicinepresciption        map[int]struct{}
	removedmedicinepresciption map[int]struct{}
	order                      map[int]struct{}
	removedorder               map[int]struct{}
	done                       bool
	oldValue                   func(context.Context) (*Medicine, error)
}

var _ ent.Mutation = (*MedicineMutation)(nil)

// medicineOption allows to manage the mutation configuration using functional options.
type medicineOption func(*MedicineMutation)

// newMedicineMutation creates new mutation for $n.Name.
func newMedicineMutation(c config, op Op, opts ...medicineOption) *MedicineMutation {
	m := &MedicineMutation{
		config:        c,
		op:            op,
		typ:           TypeMedicine,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMedicineID sets the id field of the mutation.
func withMedicineID(id int) medicineOption {
	return func(m *MedicineMutation) {
		var (
			err   error
			once  sync.Once
			value *Medicine
		)
		m.oldValue = func(ctx context.Context) (*Medicine, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Medicine.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMedicine sets the old Medicine of the mutation.
func withMedicine(node *Medicine) medicineOption {
	return func(m *MedicineMutation) {
		m.oldValue = func(context.Context) (*Medicine, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MedicineMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MedicineMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *MedicineMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *MedicineMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *MedicineMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Medicine.
// If the Medicine object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MedicineMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *MedicineMutation) ResetName() {
	m.name = nil
}

// SetSerial sets the serial field.
func (m *MedicineMutation) SetSerial(s string) {
	m.serial = &s
}

// Serial returns the serial value in the mutation.
func (m *MedicineMutation) Serial() (r string, exists bool) {
	v := m.serial
	if v == nil {
		return
	}
	return *v, true
}

// OldSerial returns the old serial value of the Medicine.
// If the Medicine object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MedicineMutation) OldSerial(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSerial is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSerial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerial: %w", err)
	}
	return oldValue.Serial, nil
}

// ResetSerial reset all changes of the "serial" field.
func (m *MedicineMutation) ResetSerial() {
	m.serial = nil
}

// SetBrand sets the brand field.
func (m *MedicineMutation) SetBrand(s string) {
	m.brand = &s
}

// Brand returns the brand value in the mutation.
func (m *MedicineMutation) Brand() (r string, exists bool) {
	v := m.brand
	if v == nil {
		return
	}
	return *v, true
}

// OldBrand returns the old brand value of the Medicine.
// If the Medicine object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MedicineMutation) OldBrand(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBrand is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBrand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrand: %w", err)
	}
	return oldValue.Brand, nil
}

// ResetBrand reset all changes of the "brand" field.
func (m *MedicineMutation) ResetBrand() {
	m.brand = nil
}

// SetAmount sets the amount field.
func (m *MedicineMutation) SetAmount(i int) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the amount value in the mutation.
func (m *MedicineMutation) Amount() (r int, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old amount value of the Medicine.
// If the Medicine object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MedicineMutation) OldAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAmount is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to amount.
func (m *MedicineMutation) AddAmount(i int) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the amount field in this mutation.
func (m *MedicineMutation) AddedAmount() (r int, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount reset all changes of the "amount" field.
func (m *MedicineMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetPrice sets the price field.
func (m *MedicineMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the price value in the mutation.
func (m *MedicineMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old price value of the Medicine.
// If the Medicine object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MedicineMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrice is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to price.
func (m *MedicineMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the price field in this mutation.
func (m *MedicineMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice reset all changes of the "price" field.
func (m *MedicineMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetHowtouse sets the howtouse field.
func (m *MedicineMutation) SetHowtouse(s string) {
	m.howtouse = &s
}

// Howtouse returns the howtouse value in the mutation.
func (m *MedicineMutation) Howtouse() (r string, exists bool) {
	v := m.howtouse
	if v == nil {
		return
	}
	return *v, true
}

// OldHowtouse returns the old howtouse value of the Medicine.
// If the Medicine object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MedicineMutation) OldHowtouse(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHowtouse is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHowtouse requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHowtouse: %w", err)
	}
	return oldValue.Howtouse, nil
}

// ResetHowtouse reset all changes of the "howtouse" field.
func (m *MedicineMutation) ResetHowtouse() {
	m.howtouse = nil
}

// SetLevelOfDangerousID sets the LevelOfDangerous edge to LevelOfDangerous by id.
func (m *MedicineMutation) SetLevelOfDangerousID(id int) {
	m._LevelOfDangerous = &id
}

// ClearLevelOfDangerous clears the LevelOfDangerous edge to LevelOfDangerous.
func (m *MedicineMutation) ClearLevelOfDangerous() {
	m.cleared_LevelOfDangerous = true
}

// LevelOfDangerousCleared returns if the edge LevelOfDangerous was cleared.
func (m *MedicineMutation) LevelOfDangerousCleared() bool {
	return m.cleared_LevelOfDangerous
}

// LevelOfDangerousID returns the LevelOfDangerous id in the mutation.
func (m *MedicineMutation) LevelOfDangerousID() (id int, exists bool) {
	if m._LevelOfDangerous != nil {
		return *m._LevelOfDangerous, true
	}
	return
}

// LevelOfDangerousIDs returns the LevelOfDangerous ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// LevelOfDangerousID instead. It exists only for internal usage by the builders.
func (m *MedicineMutation) LevelOfDangerousIDs() (ids []int) {
	if id := m._LevelOfDangerous; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLevelOfDangerous reset all changes of the "LevelOfDangerous" edge.
func (m *MedicineMutation) ResetLevelOfDangerous() {
	m._LevelOfDangerous = nil
	m.cleared_LevelOfDangerous = false
}

// SetMedicineTypeID sets the MedicineType edge to MedicineType by id.
func (m *MedicineMutation) SetMedicineTypeID(id int) {
	m._MedicineType = &id
}

// ClearMedicineType clears the MedicineType edge to MedicineType.
func (m *MedicineMutation) ClearMedicineType() {
	m.cleared_MedicineType = true
}

// MedicineTypeCleared returns if the edge MedicineType was cleared.
func (m *MedicineMutation) MedicineTypeCleared() bool {
	return m.cleared_MedicineType
}

// MedicineTypeID returns the MedicineType id in the mutation.
func (m *MedicineMutation) MedicineTypeID() (id int, exists bool) {
	if m._MedicineType != nil {
		return *m._MedicineType, true
	}
	return
}

// MedicineTypeIDs returns the MedicineType ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// MedicineTypeID instead. It exists only for internal usage by the builders.
func (m *MedicineMutation) MedicineTypeIDs() (ids []int) {
	if id := m._MedicineType; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMedicineType reset all changes of the "MedicineType" edge.
func (m *MedicineMutation) ResetMedicineType() {
	m._MedicineType = nil
	m.cleared_MedicineType = false
}

// SetUnitOfMedicineID sets the UnitOfMedicine edge to UnitOfMedicine by id.
func (m *MedicineMutation) SetUnitOfMedicineID(id int) {
	m._UnitOfMedicine = &id
}

// ClearUnitOfMedicine clears the UnitOfMedicine edge to UnitOfMedicine.
func (m *MedicineMutation) ClearUnitOfMedicine() {
	m.cleared_UnitOfMedicine = true
}

// UnitOfMedicineCleared returns if the edge UnitOfMedicine was cleared.
func (m *MedicineMutation) UnitOfMedicineCleared() bool {
	return m.cleared_UnitOfMedicine
}

// UnitOfMedicineID returns the UnitOfMedicine id in the mutation.
func (m *MedicineMutation) UnitOfMedicineID() (id int, exists bool) {
	if m._UnitOfMedicine != nil {
		return *m._UnitOfMedicine, true
	}
	return
}

// UnitOfMedicineIDs returns the UnitOfMedicine ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UnitOfMedicineID instead. It exists only for internal usage by the builders.
func (m *MedicineMutation) UnitOfMedicineIDs() (ids []int) {
	if id := m._UnitOfMedicine; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUnitOfMedicine reset all changes of the "UnitOfMedicine" edge.
func (m *MedicineMutation) ResetUnitOfMedicine() {
	m._UnitOfMedicine = nil
	m.cleared_UnitOfMedicine = false
}

// AddDrugallergyIDs adds the drugallergys edge to DrugAllergy by ids.
func (m *MedicineMutation) AddDrugallergyIDs(ids ...int) {
	if m.drugallergys == nil {
		m.drugallergys = make(map[int]struct{})
	}
	for i := range ids {
		m.drugallergys[ids[i]] = struct{}{}
	}
}

// RemoveDrugallergyIDs removes the drugallergys edge to DrugAllergy by ids.
func (m *MedicineMutation) RemoveDrugallergyIDs(ids ...int) {
	if m.removeddrugallergys == nil {
		m.removeddrugallergys = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddrugallergys[ids[i]] = struct{}{}
	}
}

// RemovedDrugallergys returns the removed ids of drugallergys.
func (m *MedicineMutation) RemovedDrugallergysIDs() (ids []int) {
	for id := range m.removeddrugallergys {
		ids = append(ids, id)
	}
	return
}

// DrugallergysIDs returns the drugallergys ids in the mutation.
func (m *MedicineMutation) DrugallergysIDs() (ids []int) {
	for id := range m.drugallergys {
		ids = append(ids, id)
	}
	return
}

// ResetDrugallergys reset all changes of the "drugallergys" edge.
func (m *MedicineMutation) ResetDrugallergys() {
	m.drugallergys = nil
	m.removeddrugallergys = nil
}

// AddMedicinepresciptionIDs adds the medicinepresciption edge to Prescription by ids.
func (m *MedicineMutation) AddMedicinepresciptionIDs(ids ...int) {
	if m.medicinepresciption == nil {
		m.medicinepresciption = make(map[int]struct{})
	}
	for i := range ids {
		m.medicinepresciption[ids[i]] = struct{}{}
	}
}

// RemoveMedicinepresciptionIDs removes the medicinepresciption edge to Prescription by ids.
func (m *MedicineMutation) RemoveMedicinepresciptionIDs(ids ...int) {
	if m.removedmedicinepresciption == nil {
		m.removedmedicinepresciption = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmedicinepresciption[ids[i]] = struct{}{}
	}
}

// RemovedMedicinepresciption returns the removed ids of medicinepresciption.
func (m *MedicineMutation) RemovedMedicinepresciptionIDs() (ids []int) {
	for id := range m.removedmedicinepresciption {
		ids = append(ids, id)
	}
	return
}

// MedicinepresciptionIDs returns the medicinepresciption ids in the mutation.
func (m *MedicineMutation) MedicinepresciptionIDs() (ids []int) {
	for id := range m.medicinepresciption {
		ids = append(ids, id)
	}
	return
}

// ResetMedicinepresciption reset all changes of the "medicinepresciption" edge.
func (m *MedicineMutation) ResetMedicinepresciption() {
	m.medicinepresciption = nil
	m.removedmedicinepresciption = nil
}

// AddOrderIDs adds the order edge to Order by ids.
func (m *MedicineMutation) AddOrderIDs(ids ...int) {
	if m.order == nil {
		m.order = make(map[int]struct{})
	}
	for i := range ids {
		m.order[ids[i]] = struct{}{}
	}
}

// RemoveOrderIDs removes the order edge to Order by ids.
func (m *MedicineMutation) RemoveOrderIDs(ids ...int) {
	if m.removedorder == nil {
		m.removedorder = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorder[ids[i]] = struct{}{}
	}
}

// RemovedOrder returns the removed ids of order.
func (m *MedicineMutation) RemovedOrderIDs() (ids []int) {
	for id := range m.removedorder {
		ids = append(ids, id)
	}
	return
}

// OrderIDs returns the order ids in the mutation.
func (m *MedicineMutation) OrderIDs() (ids []int) {
	for id := range m.order {
		ids = append(ids, id)
	}
	return
}

// ResetOrder reset all changes of the "order" edge.
func (m *MedicineMutation) ResetOrder() {
	m.order = nil
	m.removedorder = nil
}

// Op returns the operation name.
func (m *MedicineMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Medicine).
func (m *MedicineMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *MedicineMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, medicine.FieldName)
	}
	if m.serial != nil {
		fields = append(fields, medicine.FieldSerial)
	}
	if m.brand != nil {
		fields = append(fields, medicine.FieldBrand)
	}
	if m.amount != nil {
		fields = append(fields, medicine.FieldAmount)
	}
	if m.price != nil {
		fields = append(fields, medicine.FieldPrice)
	}
	if m.howtouse != nil {
		fields = append(fields, medicine.FieldHowtouse)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *MedicineMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case medicine.FieldName:
		return m.Name()
	case medicine.FieldSerial:
		return m.Serial()
	case medicine.FieldBrand:
		return m.Brand()
	case medicine.FieldAmount:
		return m.Amount()
	case medicine.FieldPrice:
		return m.Price()
	case medicine.FieldHowtouse:
		return m.Howtouse()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *MedicineMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case medicine.FieldName:
		return m.OldName(ctx)
	case medicine.FieldSerial:
		return m.OldSerial(ctx)
	case medicine.FieldBrand:
		return m.OldBrand(ctx)
	case medicine.FieldAmount:
		return m.OldAmount(ctx)
	case medicine.FieldPrice:
		return m.OldPrice(ctx)
	case medicine.FieldHowtouse:
		return m.OldHowtouse(ctx)
	}
	return nil, fmt.Errorf("unknown Medicine field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MedicineMutation) SetField(name string, value ent.Value) error {
	switch name {
	case medicine.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case medicine.FieldSerial:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerial(v)
		return nil
	case medicine.FieldBrand:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrand(v)
		return nil
	case medicine.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case medicine.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case medicine.FieldHowtouse:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHowtouse(v)
		return nil
	}
	return fmt.Errorf("unknown Medicine field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *MedicineMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, medicine.FieldAmount)
	}
	if m.addprice != nil {
		fields = append(fields, medicine.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *MedicineMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case medicine.FieldAmount:
		return m.AddedAmount()
	case medicine.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MedicineMutation) AddField(name string, value ent.Value) error {
	switch name {
	case medicine.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case medicine.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Medicine numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *MedicineMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *MedicineMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *MedicineMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Medicine nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *MedicineMutation) ResetField(name string) error {
	switch name {
	case medicine.FieldName:
		m.ResetName()
		return nil
	case medicine.FieldSerial:
		m.ResetSerial()
		return nil
	case medicine.FieldBrand:
		m.ResetBrand()
		return nil
	case medicine.FieldAmount:
		m.ResetAmount()
		return nil
	case medicine.FieldPrice:
		m.ResetPrice()
		return nil
	case medicine.FieldHowtouse:
		m.ResetHowtouse()
		return nil
	}
	return fmt.Errorf("unknown Medicine field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *MedicineMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m._LevelOfDangerous != nil {
		edges = append(edges, medicine.EdgeLevelOfDangerous)
	}
	if m._MedicineType != nil {
		edges = append(edges, medicine.EdgeMedicineType)
	}
	if m._UnitOfMedicine != nil {
		edges = append(edges, medicine.EdgeUnitOfMedicine)
	}
	if m.drugallergys != nil {
		edges = append(edges, medicine.EdgeDrugallergys)
	}
	if m.medicinepresciption != nil {
		edges = append(edges, medicine.EdgeMedicinepresciption)
	}
	if m.order != nil {
		edges = append(edges, medicine.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *MedicineMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case medicine.EdgeLevelOfDangerous:
		if id := m._LevelOfDangerous; id != nil {
			return []ent.Value{*id}
		}
	case medicine.EdgeMedicineType:
		if id := m._MedicineType; id != nil {
			return []ent.Value{*id}
		}
	case medicine.EdgeUnitOfMedicine:
		if id := m._UnitOfMedicine; id != nil {
			return []ent.Value{*id}
		}
	case medicine.EdgeDrugallergys:
		ids := make([]ent.Value, 0, len(m.drugallergys))
		for id := range m.drugallergys {
			ids = append(ids, id)
		}
		return ids
	case medicine.EdgeMedicinepresciption:
		ids := make([]ent.Value, 0, len(m.medicinepresciption))
		for id := range m.medicinepresciption {
			ids = append(ids, id)
		}
		return ids
	case medicine.EdgeOrder:
		ids := make([]ent.Value, 0, len(m.order))
		for id := range m.order {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *MedicineMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removeddrugallergys != nil {
		edges = append(edges, medicine.EdgeDrugallergys)
	}
	if m.removedmedicinepresciption != nil {
		edges = append(edges, medicine.EdgeMedicinepresciption)
	}
	if m.removedorder != nil {
		edges = append(edges, medicine.EdgeOrder)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *MedicineMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case medicine.EdgeDrugallergys:
		ids := make([]ent.Value, 0, len(m.removeddrugallergys))
		for id := range m.removeddrugallergys {
			ids = append(ids, id)
		}
		return ids
	case medicine.EdgeMedicinepresciption:
		ids := make([]ent.Value, 0, len(m.removedmedicinepresciption))
		for id := range m.removedmedicinepresciption {
			ids = append(ids, id)
		}
		return ids
	case medicine.EdgeOrder:
		ids := make([]ent.Value, 0, len(m.removedorder))
		for id := range m.removedorder {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *MedicineMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.cleared_LevelOfDangerous {
		edges = append(edges, medicine.EdgeLevelOfDangerous)
	}
	if m.cleared_MedicineType {
		edges = append(edges, medicine.EdgeMedicineType)
	}
	if m.cleared_UnitOfMedicine {
		edges = append(edges, medicine.EdgeUnitOfMedicine)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *MedicineMutation) EdgeCleared(name string) bool {
	switch name {
	case medicine.EdgeLevelOfDangerous:
		return m.cleared_LevelOfDangerous
	case medicine.EdgeMedicineType:
		return m.cleared_MedicineType
	case medicine.EdgeUnitOfMedicine:
		return m.cleared_UnitOfMedicine
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *MedicineMutation) ClearEdge(name string) error {
	switch name {
	case medicine.EdgeLevelOfDangerous:
		m.ClearLevelOfDangerous()
		return nil
	case medicine.EdgeMedicineType:
		m.ClearMedicineType()
		return nil
	case medicine.EdgeUnitOfMedicine:
		m.ClearUnitOfMedicine()
		return nil
	}
	return fmt.Errorf("unknown Medicine unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *MedicineMutation) ResetEdge(name string) error {
	switch name {
	case medicine.EdgeLevelOfDangerous:
		m.ResetLevelOfDangerous()
		return nil
	case medicine.EdgeMedicineType:
		m.ResetMedicineType()
		return nil
	case medicine.EdgeUnitOfMedicine:
		m.ResetUnitOfMedicine()
		return nil
	case medicine.EdgeDrugallergys:
		m.ResetDrugallergys()
		return nil
	case medicine.EdgeMedicinepresciption:
		m.ResetMedicinepresciption()
		return nil
	case medicine.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown Medicine edge %s", name)
}

// MedicineTypeMutation represents an operation that mutate the MedicineTypes
// nodes in the graph.
type MedicineTypeMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	clearedFields    map[string]struct{}
	_Medicine        map[int]struct{}
	removed_Medicine map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*MedicineType, error)
}

var _ ent.Mutation = (*MedicineTypeMutation)(nil)

// medicinetypeOption allows to manage the mutation configuration using functional options.
type medicinetypeOption func(*MedicineTypeMutation)

// newMedicineTypeMutation creates new mutation for $n.Name.
func newMedicineTypeMutation(c config, op Op, opts ...medicinetypeOption) *MedicineTypeMutation {
	m := &MedicineTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeMedicineType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMedicineTypeID sets the id field of the mutation.
func withMedicineTypeID(id int) medicinetypeOption {
	return func(m *MedicineTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *MedicineType
		)
		m.oldValue = func(ctx context.Context) (*MedicineType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MedicineType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMedicineType sets the old MedicineType of the mutation.
func withMedicineType(node *MedicineType) medicinetypeOption {
	return func(m *MedicineTypeMutation) {
		m.oldValue = func(context.Context) (*MedicineType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MedicineTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MedicineTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *MedicineTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *MedicineTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *MedicineTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the MedicineType.
// If the MedicineType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MedicineTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *MedicineTypeMutation) ResetName() {
	m.name = nil
}

// AddMedicineIDs adds the Medicine edge to Medicine by ids.
func (m *MedicineTypeMutation) AddMedicineIDs(ids ...int) {
	if m._Medicine == nil {
		m._Medicine = make(map[int]struct{})
	}
	for i := range ids {
		m._Medicine[ids[i]] = struct{}{}
	}
}

// RemoveMedicineIDs removes the Medicine edge to Medicine by ids.
func (m *MedicineTypeMutation) RemoveMedicineIDs(ids ...int) {
	if m.removed_Medicine == nil {
		m.removed_Medicine = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_Medicine[ids[i]] = struct{}{}
	}
}

// RemovedMedicine returns the removed ids of Medicine.
func (m *MedicineTypeMutation) RemovedMedicineIDs() (ids []int) {
	for id := range m.removed_Medicine {
		ids = append(ids, id)
	}
	return
}

// MedicineIDs returns the Medicine ids in the mutation.
func (m *MedicineTypeMutation) MedicineIDs() (ids []int) {
	for id := range m._Medicine {
		ids = append(ids, id)
	}
	return
}

// ResetMedicine reset all changes of the "Medicine" edge.
func (m *MedicineTypeMutation) ResetMedicine() {
	m._Medicine = nil
	m.removed_Medicine = nil
}

// Op returns the operation name.
func (m *MedicineTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (MedicineType).
func (m *MedicineTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *MedicineTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, medicinetype.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *MedicineTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case medicinetype.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *MedicineTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case medicinetype.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown MedicineType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MedicineTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case medicinetype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown MedicineType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *MedicineTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *MedicineTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MedicineTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MedicineType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *MedicineTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *MedicineTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *MedicineTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MedicineType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *MedicineTypeMutation) ResetField(name string) error {
	switch name {
	case medicinetype.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown MedicineType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *MedicineTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Medicine != nil {
		edges = append(edges, medicinetype.EdgeMedicine)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *MedicineTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case medicinetype.EdgeMedicine:
		ids := make([]ent.Value, 0, len(m._Medicine))
		for id := range m._Medicine {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *MedicineTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_Medicine != nil {
		edges = append(edges, medicinetype.EdgeMedicine)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *MedicineTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case medicinetype.EdgeMedicine:
		ids := make([]ent.Value, 0, len(m.removed_Medicine))
		for id := range m.removed_Medicine {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *MedicineTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *MedicineTypeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *MedicineTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown MedicineType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *MedicineTypeMutation) ResetEdge(name string) error {
	switch name {
	case medicinetype.EdgeMedicine:
		m.ResetMedicine()
		return nil
	}
	return fmt.Errorf("unknown MedicineType edge %s", name)
}

// OrderMutation represents an operation that mutate the Orders
// nodes in the graph.
type OrderMutation struct {
	config
	op                Op
	typ               string
	id                *int
	amount            *int
	addamount         *int
	price             *float64
	addprice          *float64
	total             *float64
	addtotal          *float64
	datetime          *time.Time
	clearedFields     map[string]struct{}
	pharmacist        *int
	clearedpharmacist bool
	company           map[int]struct{}
	removedcompany    map[int]struct{}
	medicine          map[int]struct{}
	removedmedicine   map[int]struct{}
	done              bool
	oldValue          func(context.Context) (*Order, error)
}

var _ ent.Mutation = (*OrderMutation)(nil)

// orderOption allows to manage the mutation configuration using functional options.
type orderOption func(*OrderMutation)

// newOrderMutation creates new mutation for $n.Name.
func newOrderMutation(c config, op Op, opts ...orderOption) *OrderMutation {
	m := &OrderMutation{
		config:        c,
		op:            op,
		typ:           TypeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderID sets the id field of the mutation.
func withOrderID(id int) orderOption {
	return func(m *OrderMutation) {
		var (
			err   error
			once  sync.Once
			value *Order
		)
		m.oldValue = func(ctx context.Context) (*Order, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Order.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrder sets the old Order of the mutation.
func withOrder(node *Order) orderOption {
	return func(m *OrderMutation) {
		m.oldValue = func(context.Context) (*Order, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *OrderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAmount sets the amount field.
func (m *OrderMutation) SetAmount(i int) {
	m.amount = &i
	m.addamount = nil
}

// Amount returns the amount value in the mutation.
func (m *OrderMutation) Amount() (r int, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old amount value of the Order.
// If the Order object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OrderMutation) OldAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAmount is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to amount.
func (m *OrderMutation) AddAmount(i int) {
	if m.addamount != nil {
		*m.addamount += i
	} else {
		m.addamount = &i
	}
}

// AddedAmount returns the value that was added to the amount field in this mutation.
func (m *OrderMutation) AddedAmount() (r int, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount reset all changes of the "amount" field.
func (m *OrderMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetPrice sets the price field.
func (m *OrderMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the price value in the mutation.
func (m *OrderMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old price value of the Order.
// If the Order object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OrderMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrice is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to price.
func (m *OrderMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the price field in this mutation.
func (m *OrderMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice reset all changes of the "price" field.
func (m *OrderMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetTotal sets the total field.
func (m *OrderMutation) SetTotal(f float64) {
	m.total = &f
	m.addtotal = nil
}

// Total returns the total value in the mutation.
func (m *OrderMutation) Total() (r float64, exists bool) {
	v := m.total
	if v == nil {
		return
	}
	return *v, true
}

// OldTotal returns the old total value of the Order.
// If the Order object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OrderMutation) OldTotal(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTotal is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotal: %w", err)
	}
	return oldValue.Total, nil
}

// AddTotal adds f to total.
func (m *OrderMutation) AddTotal(f float64) {
	if m.addtotal != nil {
		*m.addtotal += f
	} else {
		m.addtotal = &f
	}
}

// AddedTotal returns the value that was added to the total field in this mutation.
func (m *OrderMutation) AddedTotal() (r float64, exists bool) {
	v := m.addtotal
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotal reset all changes of the "total" field.
func (m *OrderMutation) ResetTotal() {
	m.total = nil
	m.addtotal = nil
}

// SetDatetime sets the datetime field.
func (m *OrderMutation) SetDatetime(t time.Time) {
	m.datetime = &t
}

// Datetime returns the datetime value in the mutation.
func (m *OrderMutation) Datetime() (r time.Time, exists bool) {
	v := m.datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldDatetime returns the old datetime value of the Order.
// If the Order object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OrderMutation) OldDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDatetime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatetime: %w", err)
	}
	return oldValue.Datetime, nil
}

// ResetDatetime reset all changes of the "datetime" field.
func (m *OrderMutation) ResetDatetime() {
	m.datetime = nil
}

// SetPharmacistID sets the pharmacist edge to Pharmacist by id.
func (m *OrderMutation) SetPharmacistID(id int) {
	m.pharmacist = &id
}

// ClearPharmacist clears the pharmacist edge to Pharmacist.
func (m *OrderMutation) ClearPharmacist() {
	m.clearedpharmacist = true
}

// PharmacistCleared returns if the edge pharmacist was cleared.
func (m *OrderMutation) PharmacistCleared() bool {
	return m.clearedpharmacist
}

// PharmacistID returns the pharmacist id in the mutation.
func (m *OrderMutation) PharmacistID() (id int, exists bool) {
	if m.pharmacist != nil {
		return *m.pharmacist, true
	}
	return
}

// PharmacistIDs returns the pharmacist ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PharmacistID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) PharmacistIDs() (ids []int) {
	if id := m.pharmacist; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPharmacist reset all changes of the "pharmacist" edge.
func (m *OrderMutation) ResetPharmacist() {
	m.pharmacist = nil
	m.clearedpharmacist = false
}

// AddCompanyIDs adds the company edge to Company by ids.
func (m *OrderMutation) AddCompanyIDs(ids ...int) {
	if m.company == nil {
		m.company = make(map[int]struct{})
	}
	for i := range ids {
		m.company[ids[i]] = struct{}{}
	}
}

// RemoveCompanyIDs removes the company edge to Company by ids.
func (m *OrderMutation) RemoveCompanyIDs(ids ...int) {
	if m.removedcompany == nil {
		m.removedcompany = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcompany[ids[i]] = struct{}{}
	}
}

// RemovedCompany returns the removed ids of company.
func (m *OrderMutation) RemovedCompanyIDs() (ids []int) {
	for id := range m.removedcompany {
		ids = append(ids, id)
	}
	return
}

// CompanyIDs returns the company ids in the mutation.
func (m *OrderMutation) CompanyIDs() (ids []int) {
	for id := range m.company {
		ids = append(ids, id)
	}
	return
}

// ResetCompany reset all changes of the "company" edge.
func (m *OrderMutation) ResetCompany() {
	m.company = nil
	m.removedcompany = nil
}

// AddMedicineIDs adds the medicine edge to Medicine by ids.
func (m *OrderMutation) AddMedicineIDs(ids ...int) {
	if m.medicine == nil {
		m.medicine = make(map[int]struct{})
	}
	for i := range ids {
		m.medicine[ids[i]] = struct{}{}
	}
}

// RemoveMedicineIDs removes the medicine edge to Medicine by ids.
func (m *OrderMutation) RemoveMedicineIDs(ids ...int) {
	if m.removedmedicine == nil {
		m.removedmedicine = make(map[int]struct{})
	}
	for i := range ids {
		m.removedmedicine[ids[i]] = struct{}{}
	}
}

// RemovedMedicine returns the removed ids of medicine.
func (m *OrderMutation) RemovedMedicineIDs() (ids []int) {
	for id := range m.removedmedicine {
		ids = append(ids, id)
	}
	return
}

// MedicineIDs returns the medicine ids in the mutation.
func (m *OrderMutation) MedicineIDs() (ids []int) {
	for id := range m.medicine {
		ids = append(ids, id)
	}
	return
}

// ResetMedicine reset all changes of the "medicine" edge.
func (m *OrderMutation) ResetMedicine() {
	m.medicine = nil
	m.removedmedicine = nil
}

// Op returns the operation name.
func (m *OrderMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Order).
func (m *OrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *OrderMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.amount != nil {
		fields = append(fields, order.FieldAmount)
	}
	if m.price != nil {
		fields = append(fields, order.FieldPrice)
	}
	if m.total != nil {
		fields = append(fields, order.FieldTotal)
	}
	if m.datetime != nil {
		fields = append(fields, order.FieldDatetime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *OrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case order.FieldAmount:
		return m.Amount()
	case order.FieldPrice:
		return m.Price()
	case order.FieldTotal:
		return m.Total()
	case order.FieldDatetime:
		return m.Datetime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *OrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case order.FieldAmount:
		return m.OldAmount(ctx)
	case order.FieldPrice:
		return m.OldPrice(ctx)
	case order.FieldTotal:
		return m.OldTotal(ctx)
	case order.FieldDatetime:
		return m.OldDatetime(ctx)
	}
	return nil, fmt.Errorf("unknown Order field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case order.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case order.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case order.FieldTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotal(v)
		return nil
	case order.FieldDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatetime(v)
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *OrderMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, order.FieldAmount)
	}
	if m.addprice != nil {
		fields = append(fields, order.FieldPrice)
	}
	if m.addtotal != nil {
		fields = append(fields, order.FieldTotal)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *OrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case order.FieldAmount:
		return m.AddedAmount()
	case order.FieldPrice:
		return m.AddedPrice()
	case order.FieldTotal:
		return m.AddedTotal()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case order.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case order.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case order.FieldTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotal(v)
		return nil
	}
	return fmt.Errorf("unknown Order numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *OrderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *OrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Order nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *OrderMutation) ResetField(name string) error {
	switch name {
	case order.FieldAmount:
		m.ResetAmount()
		return nil
	case order.FieldPrice:
		m.ResetPrice()
		return nil
	case order.FieldTotal:
		m.ResetTotal()
		return nil
	case order.FieldDatetime:
		m.ResetDatetime()
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *OrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.pharmacist != nil {
		edges = append(edges, order.EdgePharmacist)
	}
	if m.company != nil {
		edges = append(edges, order.EdgeCompany)
	}
	if m.medicine != nil {
		edges = append(edges, order.EdgeMedicine)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *OrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case order.EdgePharmacist:
		if id := m.pharmacist; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeCompany:
		ids := make([]ent.Value, 0, len(m.company))
		for id := range m.company {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeMedicine:
		ids := make([]ent.Value, 0, len(m.medicine))
		for id := range m.medicine {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *OrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcompany != nil {
		edges = append(edges, order.EdgeCompany)
	}
	if m.removedmedicine != nil {
		edges = append(edges, order.EdgeMedicine)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *OrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeCompany:
		ids := make([]ent.Value, 0, len(m.removedcompany))
		for id := range m.removedcompany {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeMedicine:
		ids := make([]ent.Value, 0, len(m.removedmedicine))
		for id := range m.removedmedicine {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *OrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedpharmacist {
		edges = append(edges, order.EdgePharmacist)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *OrderMutation) EdgeCleared(name string) bool {
	switch name {
	case order.EdgePharmacist:
		return m.clearedpharmacist
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *OrderMutation) ClearEdge(name string) error {
	switch name {
	case order.EdgePharmacist:
		m.ClearPharmacist()
		return nil
	}
	return fmt.Errorf("unknown Order unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *OrderMutation) ResetEdge(name string) error {
	switch name {
	case order.EdgePharmacist:
		m.ResetPharmacist()
		return nil
	case order.EdgeCompany:
		m.ResetCompany()
		return nil
	case order.EdgeMedicine:
		m.ResetMedicine()
		return nil
	}
	return fmt.Errorf("unknown Order edge %s", name)
}

// PatientInfoMutation represents an operation that mutate the PatientInfos
// nodes in the graph.
type PatientInfoMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	cardNumber                 *string
	name                       *string
	gender                     *string
	age                        *int
	addage                     *int
	clearedFields              map[string]struct{}
	drugallergys               map[int]struct{}
	removeddrugallergys        map[int]struct{}
	patientprescription        map[int]struct{}
	removedpatientprescription map[int]struct{}
	done                       bool
	oldValue                   func(context.Context) (*PatientInfo, error)
}

var _ ent.Mutation = (*PatientInfoMutation)(nil)

// patientinfoOption allows to manage the mutation configuration using functional options.
type patientinfoOption func(*PatientInfoMutation)

// newPatientInfoMutation creates new mutation for $n.Name.
func newPatientInfoMutation(c config, op Op, opts ...patientinfoOption) *PatientInfoMutation {
	m := &PatientInfoMutation{
		config:        c,
		op:            op,
		typ:           TypePatientInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPatientInfoID sets the id field of the mutation.
func withPatientInfoID(id int) patientinfoOption {
	return func(m *PatientInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *PatientInfo
		)
		m.oldValue = func(ctx context.Context) (*PatientInfo, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PatientInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPatientInfo sets the old PatientInfo of the mutation.
func withPatientInfo(node *PatientInfo) patientinfoOption {
	return func(m *PatientInfoMutation) {
		m.oldValue = func(context.Context) (*PatientInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PatientInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PatientInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PatientInfoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCardNumber sets the cardNumber field.
func (m *PatientInfoMutation) SetCardNumber(s string) {
	m.cardNumber = &s
}

// CardNumber returns the cardNumber value in the mutation.
func (m *PatientInfoMutation) CardNumber() (r string, exists bool) {
	v := m.cardNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldCardNumber returns the old cardNumber value of the PatientInfo.
// If the PatientInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientInfoMutation) OldCardNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCardNumber is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCardNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCardNumber: %w", err)
	}
	return oldValue.CardNumber, nil
}

// ResetCardNumber reset all changes of the "cardNumber" field.
func (m *PatientInfoMutation) ResetCardNumber() {
	m.cardNumber = nil
}

// SetName sets the name field.
func (m *PatientInfoMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *PatientInfoMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the PatientInfo.
// If the PatientInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientInfoMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *PatientInfoMutation) ResetName() {
	m.name = nil
}

// SetGender sets the gender field.
func (m *PatientInfoMutation) SetGender(s string) {
	m.gender = &s
}

// Gender returns the gender value in the mutation.
func (m *PatientInfoMutation) Gender() (r string, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old gender value of the PatientInfo.
// If the PatientInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientInfoMutation) OldGender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGender is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ResetGender reset all changes of the "gender" field.
func (m *PatientInfoMutation) ResetGender() {
	m.gender = nil
}

// SetAge sets the age field.
func (m *PatientInfoMutation) SetAge(i int) {
	m.age = &i
	m.addage = nil
}

// Age returns the age value in the mutation.
func (m *PatientInfoMutation) Age() (r int, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old age value of the PatientInfo.
// If the PatientInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientInfoMutation) OldAge(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAge is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds i to age.
func (m *PatientInfoMutation) AddAge(i int) {
	if m.addage != nil {
		*m.addage += i
	} else {
		m.addage = &i
	}
}

// AddedAge returns the value that was added to the age field in this mutation.
func (m *PatientInfoMutation) AddedAge() (r int, exists bool) {
	v := m.addage
	if v == nil {
		return
	}
	return *v, true
}

// ResetAge reset all changes of the "age" field.
func (m *PatientInfoMutation) ResetAge() {
	m.age = nil
	m.addage = nil
}

// AddDrugallergyIDs adds the drugallergys edge to DrugAllergy by ids.
func (m *PatientInfoMutation) AddDrugallergyIDs(ids ...int) {
	if m.drugallergys == nil {
		m.drugallergys = make(map[int]struct{})
	}
	for i := range ids {
		m.drugallergys[ids[i]] = struct{}{}
	}
}

// RemoveDrugallergyIDs removes the drugallergys edge to DrugAllergy by ids.
func (m *PatientInfoMutation) RemoveDrugallergyIDs(ids ...int) {
	if m.removeddrugallergys == nil {
		m.removeddrugallergys = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddrugallergys[ids[i]] = struct{}{}
	}
}

// RemovedDrugallergys returns the removed ids of drugallergys.
func (m *PatientInfoMutation) RemovedDrugallergysIDs() (ids []int) {
	for id := range m.removeddrugallergys {
		ids = append(ids, id)
	}
	return
}

// DrugallergysIDs returns the drugallergys ids in the mutation.
func (m *PatientInfoMutation) DrugallergysIDs() (ids []int) {
	for id := range m.drugallergys {
		ids = append(ids, id)
	}
	return
}

// ResetDrugallergys reset all changes of the "drugallergys" edge.
func (m *PatientInfoMutation) ResetDrugallergys() {
	m.drugallergys = nil
	m.removeddrugallergys = nil
}

// AddPatientprescriptionIDs adds the patientprescription edge to Prescription by ids.
func (m *PatientInfoMutation) AddPatientprescriptionIDs(ids ...int) {
	if m.patientprescription == nil {
		m.patientprescription = make(map[int]struct{})
	}
	for i := range ids {
		m.patientprescription[ids[i]] = struct{}{}
	}
}

// RemovePatientprescriptionIDs removes the patientprescription edge to Prescription by ids.
func (m *PatientInfoMutation) RemovePatientprescriptionIDs(ids ...int) {
	if m.removedpatientprescription == nil {
		m.removedpatientprescription = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpatientprescription[ids[i]] = struct{}{}
	}
}

// RemovedPatientprescription returns the removed ids of patientprescription.
func (m *PatientInfoMutation) RemovedPatientprescriptionIDs() (ids []int) {
	for id := range m.removedpatientprescription {
		ids = append(ids, id)
	}
	return
}

// PatientprescriptionIDs returns the patientprescription ids in the mutation.
func (m *PatientInfoMutation) PatientprescriptionIDs() (ids []int) {
	for id := range m.patientprescription {
		ids = append(ids, id)
	}
	return
}

// ResetPatientprescription reset all changes of the "patientprescription" edge.
func (m *PatientInfoMutation) ResetPatientprescription() {
	m.patientprescription = nil
	m.removedpatientprescription = nil
}

// Op returns the operation name.
func (m *PatientInfoMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PatientInfo).
func (m *PatientInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PatientInfoMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.cardNumber != nil {
		fields = append(fields, patientinfo.FieldCardNumber)
	}
	if m.name != nil {
		fields = append(fields, patientinfo.FieldName)
	}
	if m.gender != nil {
		fields = append(fields, patientinfo.FieldGender)
	}
	if m.age != nil {
		fields = append(fields, patientinfo.FieldAge)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PatientInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case patientinfo.FieldCardNumber:
		return m.CardNumber()
	case patientinfo.FieldName:
		return m.Name()
	case patientinfo.FieldGender:
		return m.Gender()
	case patientinfo.FieldAge:
		return m.Age()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PatientInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case patientinfo.FieldCardNumber:
		return m.OldCardNumber(ctx)
	case patientinfo.FieldName:
		return m.OldName(ctx)
	case patientinfo.FieldGender:
		return m.OldGender(ctx)
	case patientinfo.FieldAge:
		return m.OldAge(ctx)
	}
	return nil, fmt.Errorf("unknown PatientInfo field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PatientInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case patientinfo.FieldCardNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCardNumber(v)
		return nil
	case patientinfo.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case patientinfo.FieldGender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case patientinfo.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	}
	return fmt.Errorf("unknown PatientInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PatientInfoMutation) AddedFields() []string {
	var fields []string
	if m.addage != nil {
		fields = append(fields, patientinfo.FieldAge)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PatientInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case patientinfo.FieldAge:
		return m.AddedAge()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PatientInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case patientinfo.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	}
	return fmt.Errorf("unknown PatientInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PatientInfoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PatientInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PatientInfoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PatientInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PatientInfoMutation) ResetField(name string) error {
	switch name {
	case patientinfo.FieldCardNumber:
		m.ResetCardNumber()
		return nil
	case patientinfo.FieldName:
		m.ResetName()
		return nil
	case patientinfo.FieldGender:
		m.ResetGender()
		return nil
	case patientinfo.FieldAge:
		m.ResetAge()
		return nil
	}
	return fmt.Errorf("unknown PatientInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PatientInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.drugallergys != nil {
		edges = append(edges, patientinfo.EdgeDrugallergys)
	}
	if m.patientprescription != nil {
		edges = append(edges, patientinfo.EdgePatientprescription)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PatientInfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case patientinfo.EdgeDrugallergys:
		ids := make([]ent.Value, 0, len(m.drugallergys))
		for id := range m.drugallergys {
			ids = append(ids, id)
		}
		return ids
	case patientinfo.EdgePatientprescription:
		ids := make([]ent.Value, 0, len(m.patientprescription))
		for id := range m.patientprescription {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PatientInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddrugallergys != nil {
		edges = append(edges, patientinfo.EdgeDrugallergys)
	}
	if m.removedpatientprescription != nil {
		edges = append(edges, patientinfo.EdgePatientprescription)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PatientInfoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case patientinfo.EdgeDrugallergys:
		ids := make([]ent.Value, 0, len(m.removeddrugallergys))
		for id := range m.removeddrugallergys {
			ids = append(ids, id)
		}
		return ids
	case patientinfo.EdgePatientprescription:
		ids := make([]ent.Value, 0, len(m.removedpatientprescription))
		for id := range m.removedpatientprescription {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PatientInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PatientInfoMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PatientInfoMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PatientInfo unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PatientInfoMutation) ResetEdge(name string) error {
	switch name {
	case patientinfo.EdgeDrugallergys:
		m.ResetDrugallergys()
		return nil
	case patientinfo.EdgePatientprescription:
		m.ResetPatientprescription()
		return nil
	}
	return fmt.Errorf("unknown PatientInfo edge %s", name)
}

// PaymentMutation represents an operation that mutate the Payments
// nodes in the graph.
type PaymentMutation struct {
	config
	op            Op
	typ           string
	id            *int
	pay           *string
	clearedFields map[string]struct{}
	_Bills        map[int]struct{}
	removed_Bills map[int]struct{}
	done          bool
	oldValue      func(context.Context) (*Payment, error)
}

var _ ent.Mutation = (*PaymentMutation)(nil)

// paymentOption allows to manage the mutation configuration using functional options.
type paymentOption func(*PaymentMutation)

// newPaymentMutation creates new mutation for $n.Name.
func newPaymentMutation(c config, op Op, opts ...paymentOption) *PaymentMutation {
	m := &PaymentMutation{
		config:        c,
		op:            op,
		typ:           TypePayment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentID sets the id field of the mutation.
func withPaymentID(id int) paymentOption {
	return func(m *PaymentMutation) {
		var (
			err   error
			once  sync.Once
			value *Payment
		)
		m.oldValue = func(ctx context.Context) (*Payment, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Payment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPayment sets the old Payment of the mutation.
func withPayment(node *Payment) paymentOption {
	return func(m *PaymentMutation) {
		m.oldValue = func(context.Context) (*Payment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PaymentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPay sets the pay field.
func (m *PaymentMutation) SetPay(s string) {
	m.pay = &s
}

// Pay returns the pay value in the mutation.
func (m *PaymentMutation) Pay() (r string, exists bool) {
	v := m.pay
	if v == nil {
		return
	}
	return *v, true
}

// OldPay returns the old pay value of the Payment.
// If the Payment object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PaymentMutation) OldPay(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPay is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPay: %w", err)
	}
	return oldValue.Pay, nil
}

// ResetPay reset all changes of the "pay" field.
func (m *PaymentMutation) ResetPay() {
	m.pay = nil
}

// AddBillIDs adds the Bills edge to Bill by ids.
func (m *PaymentMutation) AddBillIDs(ids ...int) {
	if m._Bills == nil {
		m._Bills = make(map[int]struct{})
	}
	for i := range ids {
		m._Bills[ids[i]] = struct{}{}
	}
}

// RemoveBillIDs removes the Bills edge to Bill by ids.
func (m *PaymentMutation) RemoveBillIDs(ids ...int) {
	if m.removed_Bills == nil {
		m.removed_Bills = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_Bills[ids[i]] = struct{}{}
	}
}

// RemovedBills returns the removed ids of Bills.
func (m *PaymentMutation) RemovedBillsIDs() (ids []int) {
	for id := range m.removed_Bills {
		ids = append(ids, id)
	}
	return
}

// BillsIDs returns the Bills ids in the mutation.
func (m *PaymentMutation) BillsIDs() (ids []int) {
	for id := range m._Bills {
		ids = append(ids, id)
	}
	return
}

// ResetBills reset all changes of the "Bills" edge.
func (m *PaymentMutation) ResetBills() {
	m._Bills = nil
	m.removed_Bills = nil
}

// Op returns the operation name.
func (m *PaymentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Payment).
func (m *PaymentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PaymentMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.pay != nil {
		fields = append(fields, payment.FieldPay)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PaymentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case payment.FieldPay:
		return m.Pay()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PaymentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case payment.FieldPay:
		return m.OldPay(ctx)
	}
	return nil, fmt.Errorf("unknown Payment field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PaymentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case payment.FieldPay:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPay(v)
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PaymentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PaymentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PaymentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Payment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PaymentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PaymentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Payment nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PaymentMutation) ResetField(name string) error {
	switch name {
	case payment.FieldPay:
		m.ResetPay()
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PaymentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Bills != nil {
		edges = append(edges, payment.EdgeBills)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PaymentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case payment.EdgeBills:
		ids := make([]ent.Value, 0, len(m._Bills))
		for id := range m._Bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PaymentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_Bills != nil {
		edges = append(edges, payment.EdgeBills)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PaymentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case payment.EdgeBills:
		ids := make([]ent.Value, 0, len(m.removed_Bills))
		for id := range m.removed_Bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PaymentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PaymentMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PaymentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Payment unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PaymentMutation) ResetEdge(name string) error {
	switch name {
	case payment.EdgeBills:
		m.ResetBills()
		return nil
	}
	return fmt.Errorf("unknown Payment edge %s", name)
}

// PharmacistMutation represents an operation that mutate the Pharmacists
// nodes in the graph.
type PharmacistMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	email                   *string
	password                *string
	name                    *string
	clearedFields           map[string]struct{}
	dispensemedicine        map[int]struct{}
	removeddispensemedicine map[int]struct{}
	drugallergys            map[int]struct{}
	removeddrugallergys     map[int]struct{}
	order                   map[int]struct{}
	removedorder            map[int]struct{}
	_Bills                  map[int]struct{}
	removed_Bills           map[int]struct{}
	done                    bool
	oldValue                func(context.Context) (*Pharmacist, error)
}

var _ ent.Mutation = (*PharmacistMutation)(nil)

// pharmacistOption allows to manage the mutation configuration using functional options.
type pharmacistOption func(*PharmacistMutation)

// newPharmacistMutation creates new mutation for $n.Name.
func newPharmacistMutation(c config, op Op, opts ...pharmacistOption) *PharmacistMutation {
	m := &PharmacistMutation{
		config:        c,
		op:            op,
		typ:           TypePharmacist,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPharmacistID sets the id field of the mutation.
func withPharmacistID(id int) pharmacistOption {
	return func(m *PharmacistMutation) {
		var (
			err   error
			once  sync.Once
			value *Pharmacist
		)
		m.oldValue = func(ctx context.Context) (*Pharmacist, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Pharmacist.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPharmacist sets the old Pharmacist of the mutation.
func withPharmacist(node *Pharmacist) pharmacistOption {
	return func(m *PharmacistMutation) {
		m.oldValue = func(context.Context) (*Pharmacist, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PharmacistMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PharmacistMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PharmacistMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEmail sets the email field.
func (m *PharmacistMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the email value in the mutation.
func (m *PharmacistMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old email value of the Pharmacist.
// If the Pharmacist object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PharmacistMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail reset all changes of the "email" field.
func (m *PharmacistMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the password field.
func (m *PharmacistMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the password value in the mutation.
func (m *PharmacistMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old password value of the Pharmacist.
// If the Pharmacist object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PharmacistMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword reset all changes of the "password" field.
func (m *PharmacistMutation) ResetPassword() {
	m.password = nil
}

// SetName sets the name field.
func (m *PharmacistMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *PharmacistMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Pharmacist.
// If the Pharmacist object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PharmacistMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *PharmacistMutation) ResetName() {
	m.name = nil
}

// AddDispensemedicineIDs adds the dispensemedicine edge to DispenseMedicine by ids.
func (m *PharmacistMutation) AddDispensemedicineIDs(ids ...int) {
	if m.dispensemedicine == nil {
		m.dispensemedicine = make(map[int]struct{})
	}
	for i := range ids {
		m.dispensemedicine[ids[i]] = struct{}{}
	}
}

// RemoveDispensemedicineIDs removes the dispensemedicine edge to DispenseMedicine by ids.
func (m *PharmacistMutation) RemoveDispensemedicineIDs(ids ...int) {
	if m.removeddispensemedicine == nil {
		m.removeddispensemedicine = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddispensemedicine[ids[i]] = struct{}{}
	}
}

// RemovedDispensemedicine returns the removed ids of dispensemedicine.
func (m *PharmacistMutation) RemovedDispensemedicineIDs() (ids []int) {
	for id := range m.removeddispensemedicine {
		ids = append(ids, id)
	}
	return
}

// DispensemedicineIDs returns the dispensemedicine ids in the mutation.
func (m *PharmacistMutation) DispensemedicineIDs() (ids []int) {
	for id := range m.dispensemedicine {
		ids = append(ids, id)
	}
	return
}

// ResetDispensemedicine reset all changes of the "dispensemedicine" edge.
func (m *PharmacistMutation) ResetDispensemedicine() {
	m.dispensemedicine = nil
	m.removeddispensemedicine = nil
}

// AddDrugallergyIDs adds the drugallergys edge to DrugAllergy by ids.
func (m *PharmacistMutation) AddDrugallergyIDs(ids ...int) {
	if m.drugallergys == nil {
		m.drugallergys = make(map[int]struct{})
	}
	for i := range ids {
		m.drugallergys[ids[i]] = struct{}{}
	}
}

// RemoveDrugallergyIDs removes the drugallergys edge to DrugAllergy by ids.
func (m *PharmacistMutation) RemoveDrugallergyIDs(ids ...int) {
	if m.removeddrugallergys == nil {
		m.removeddrugallergys = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddrugallergys[ids[i]] = struct{}{}
	}
}

// RemovedDrugallergys returns the removed ids of drugallergys.
func (m *PharmacistMutation) RemovedDrugallergysIDs() (ids []int) {
	for id := range m.removeddrugallergys {
		ids = append(ids, id)
	}
	return
}

// DrugallergysIDs returns the drugallergys ids in the mutation.
func (m *PharmacistMutation) DrugallergysIDs() (ids []int) {
	for id := range m.drugallergys {
		ids = append(ids, id)
	}
	return
}

// ResetDrugallergys reset all changes of the "drugallergys" edge.
func (m *PharmacistMutation) ResetDrugallergys() {
	m.drugallergys = nil
	m.removeddrugallergys = nil
}

// AddOrderIDs adds the order edge to Order by ids.
func (m *PharmacistMutation) AddOrderIDs(ids ...int) {
	if m.order == nil {
		m.order = make(map[int]struct{})
	}
	for i := range ids {
		m.order[ids[i]] = struct{}{}
	}
}

// RemoveOrderIDs removes the order edge to Order by ids.
func (m *PharmacistMutation) RemoveOrderIDs(ids ...int) {
	if m.removedorder == nil {
		m.removedorder = make(map[int]struct{})
	}
	for i := range ids {
		m.removedorder[ids[i]] = struct{}{}
	}
}

// RemovedOrder returns the removed ids of order.
func (m *PharmacistMutation) RemovedOrderIDs() (ids []int) {
	for id := range m.removedorder {
		ids = append(ids, id)
	}
	return
}

// OrderIDs returns the order ids in the mutation.
func (m *PharmacistMutation) OrderIDs() (ids []int) {
	for id := range m.order {
		ids = append(ids, id)
	}
	return
}

// ResetOrder reset all changes of the "order" edge.
func (m *PharmacistMutation) ResetOrder() {
	m.order = nil
	m.removedorder = nil
}

// AddBillIDs adds the Bills edge to Bill by ids.
func (m *PharmacistMutation) AddBillIDs(ids ...int) {
	if m._Bills == nil {
		m._Bills = make(map[int]struct{})
	}
	for i := range ids {
		m._Bills[ids[i]] = struct{}{}
	}
}

// RemoveBillIDs removes the Bills edge to Bill by ids.
func (m *PharmacistMutation) RemoveBillIDs(ids ...int) {
	if m.removed_Bills == nil {
		m.removed_Bills = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_Bills[ids[i]] = struct{}{}
	}
}

// RemovedBills returns the removed ids of Bills.
func (m *PharmacistMutation) RemovedBillsIDs() (ids []int) {
	for id := range m.removed_Bills {
		ids = append(ids, id)
	}
	return
}

// BillsIDs returns the Bills ids in the mutation.
func (m *PharmacistMutation) BillsIDs() (ids []int) {
	for id := range m._Bills {
		ids = append(ids, id)
	}
	return
}

// ResetBills reset all changes of the "Bills" edge.
func (m *PharmacistMutation) ResetBills() {
	m._Bills = nil
	m.removed_Bills = nil
}

// Op returns the operation name.
func (m *PharmacistMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Pharmacist).
func (m *PharmacistMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PharmacistMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.email != nil {
		fields = append(fields, pharmacist.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, pharmacist.FieldPassword)
	}
	if m.name != nil {
		fields = append(fields, pharmacist.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PharmacistMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pharmacist.FieldEmail:
		return m.Email()
	case pharmacist.FieldPassword:
		return m.Password()
	case pharmacist.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PharmacistMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pharmacist.FieldEmail:
		return m.OldEmail(ctx)
	case pharmacist.FieldPassword:
		return m.OldPassword(ctx)
	case pharmacist.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Pharmacist field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PharmacistMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pharmacist.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case pharmacist.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case pharmacist.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Pharmacist field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PharmacistMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PharmacistMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PharmacistMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Pharmacist numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PharmacistMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PharmacistMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PharmacistMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Pharmacist nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PharmacistMutation) ResetField(name string) error {
	switch name {
	case pharmacist.FieldEmail:
		m.ResetEmail()
		return nil
	case pharmacist.FieldPassword:
		m.ResetPassword()
		return nil
	case pharmacist.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Pharmacist field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PharmacistMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.dispensemedicine != nil {
		edges = append(edges, pharmacist.EdgeDispensemedicine)
	}
	if m.drugallergys != nil {
		edges = append(edges, pharmacist.EdgeDrugallergys)
	}
	if m.order != nil {
		edges = append(edges, pharmacist.EdgeOrder)
	}
	if m._Bills != nil {
		edges = append(edges, pharmacist.EdgeBills)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PharmacistMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pharmacist.EdgeDispensemedicine:
		ids := make([]ent.Value, 0, len(m.dispensemedicine))
		for id := range m.dispensemedicine {
			ids = append(ids, id)
		}
		return ids
	case pharmacist.EdgeDrugallergys:
		ids := make([]ent.Value, 0, len(m.drugallergys))
		for id := range m.drugallergys {
			ids = append(ids, id)
		}
		return ids
	case pharmacist.EdgeOrder:
		ids := make([]ent.Value, 0, len(m.order))
		for id := range m.order {
			ids = append(ids, id)
		}
		return ids
	case pharmacist.EdgeBills:
		ids := make([]ent.Value, 0, len(m._Bills))
		for id := range m._Bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PharmacistMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removeddispensemedicine != nil {
		edges = append(edges, pharmacist.EdgeDispensemedicine)
	}
	if m.removeddrugallergys != nil {
		edges = append(edges, pharmacist.EdgeDrugallergys)
	}
	if m.removedorder != nil {
		edges = append(edges, pharmacist.EdgeOrder)
	}
	if m.removed_Bills != nil {
		edges = append(edges, pharmacist.EdgeBills)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PharmacistMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case pharmacist.EdgeDispensemedicine:
		ids := make([]ent.Value, 0, len(m.removeddispensemedicine))
		for id := range m.removeddispensemedicine {
			ids = append(ids, id)
		}
		return ids
	case pharmacist.EdgeDrugallergys:
		ids := make([]ent.Value, 0, len(m.removeddrugallergys))
		for id := range m.removeddrugallergys {
			ids = append(ids, id)
		}
		return ids
	case pharmacist.EdgeOrder:
		ids := make([]ent.Value, 0, len(m.removedorder))
		for id := range m.removedorder {
			ids = append(ids, id)
		}
		return ids
	case pharmacist.EdgeBills:
		ids := make([]ent.Value, 0, len(m.removed_Bills))
		for id := range m.removed_Bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PharmacistMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PharmacistMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PharmacistMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Pharmacist unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PharmacistMutation) ResetEdge(name string) error {
	switch name {
	case pharmacist.EdgeDispensemedicine:
		m.ResetDispensemedicine()
		return nil
	case pharmacist.EdgeDrugallergys:
		m.ResetDrugallergys()
		return nil
	case pharmacist.EdgeOrder:
		m.ResetOrder()
		return nil
	case pharmacist.EdgeBills:
		m.ResetBills()
		return nil
	}
	return fmt.Errorf("unknown Pharmacist edge %s", name)
}

// PrescriptionMutation represents an operation that mutate the Prescriptions
// nodes in the graph.
type PrescriptionMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	value                       *int
	addvalue                    *int
	clearedFields               map[string]struct{}
	prescriptionpatient         *int
	clearedprescriptionpatient  bool
	prescriptiondoctor          *int
	clearedprescriptiondoctor   bool
	prescriptionmedicine        *int
	clearedprescriptionmedicine bool
	dispensemedicine            *int
	cleareddispensemedicine     bool
	done                        bool
	oldValue                    func(context.Context) (*Prescription, error)
}

var _ ent.Mutation = (*PrescriptionMutation)(nil)

// prescriptionOption allows to manage the mutation configuration using functional options.
type prescriptionOption func(*PrescriptionMutation)

// newPrescriptionMutation creates new mutation for $n.Name.
func newPrescriptionMutation(c config, op Op, opts ...prescriptionOption) *PrescriptionMutation {
	m := &PrescriptionMutation{
		config:        c,
		op:            op,
		typ:           TypePrescription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPrescriptionID sets the id field of the mutation.
func withPrescriptionID(id int) prescriptionOption {
	return func(m *PrescriptionMutation) {
		var (
			err   error
			once  sync.Once
			value *Prescription
		)
		m.oldValue = func(ctx context.Context) (*Prescription, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Prescription.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrescription sets the old Prescription of the mutation.
func withPrescription(node *Prescription) prescriptionOption {
	return func(m *PrescriptionMutation) {
		m.oldValue = func(context.Context) (*Prescription, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PrescriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PrescriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PrescriptionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetValue sets the value field.
func (m *PrescriptionMutation) SetValue(i int) {
	m.value = &i
	m.addvalue = nil
}

// Value returns the value value in the mutation.
func (m *PrescriptionMutation) Value() (r int, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old value value of the Prescription.
// If the Prescription object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PrescriptionMutation) OldValue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldValue is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds i to value.
func (m *PrescriptionMutation) AddValue(i int) {
	if m.addvalue != nil {
		*m.addvalue += i
	} else {
		m.addvalue = &i
	}
}

// AddedValue returns the value that was added to the value field in this mutation.
func (m *PrescriptionMutation) AddedValue() (r int, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue reset all changes of the "value" field.
func (m *PrescriptionMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetPrescriptionpatientID sets the prescriptionpatient edge to PatientInfo by id.
func (m *PrescriptionMutation) SetPrescriptionpatientID(id int) {
	m.prescriptionpatient = &id
}

// ClearPrescriptionpatient clears the prescriptionpatient edge to PatientInfo.
func (m *PrescriptionMutation) ClearPrescriptionpatient() {
	m.clearedprescriptionpatient = true
}

// PrescriptionpatientCleared returns if the edge prescriptionpatient was cleared.
func (m *PrescriptionMutation) PrescriptionpatientCleared() bool {
	return m.clearedprescriptionpatient
}

// PrescriptionpatientID returns the prescriptionpatient id in the mutation.
func (m *PrescriptionMutation) PrescriptionpatientID() (id int, exists bool) {
	if m.prescriptionpatient != nil {
		return *m.prescriptionpatient, true
	}
	return
}

// PrescriptionpatientIDs returns the prescriptionpatient ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PrescriptionpatientID instead. It exists only for internal usage by the builders.
func (m *PrescriptionMutation) PrescriptionpatientIDs() (ids []int) {
	if id := m.prescriptionpatient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrescriptionpatient reset all changes of the "prescriptionpatient" edge.
func (m *PrescriptionMutation) ResetPrescriptionpatient() {
	m.prescriptionpatient = nil
	m.clearedprescriptionpatient = false
}

// SetPrescriptiondoctorID sets the prescriptiondoctor edge to Doctor by id.
func (m *PrescriptionMutation) SetPrescriptiondoctorID(id int) {
	m.prescriptiondoctor = &id
}

// ClearPrescriptiondoctor clears the prescriptiondoctor edge to Doctor.
func (m *PrescriptionMutation) ClearPrescriptiondoctor() {
	m.clearedprescriptiondoctor = true
}

// PrescriptiondoctorCleared returns if the edge prescriptiondoctor was cleared.
func (m *PrescriptionMutation) PrescriptiondoctorCleared() bool {
	return m.clearedprescriptiondoctor
}

// PrescriptiondoctorID returns the prescriptiondoctor id in the mutation.
func (m *PrescriptionMutation) PrescriptiondoctorID() (id int, exists bool) {
	if m.prescriptiondoctor != nil {
		return *m.prescriptiondoctor, true
	}
	return
}

// PrescriptiondoctorIDs returns the prescriptiondoctor ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PrescriptiondoctorID instead. It exists only for internal usage by the builders.
func (m *PrescriptionMutation) PrescriptiondoctorIDs() (ids []int) {
	if id := m.prescriptiondoctor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrescriptiondoctor reset all changes of the "prescriptiondoctor" edge.
func (m *PrescriptionMutation) ResetPrescriptiondoctor() {
	m.prescriptiondoctor = nil
	m.clearedprescriptiondoctor = false
}

// SetPrescriptionmedicineID sets the prescriptionmedicine edge to Medicine by id.
func (m *PrescriptionMutation) SetPrescriptionmedicineID(id int) {
	m.prescriptionmedicine = &id
}

// ClearPrescriptionmedicine clears the prescriptionmedicine edge to Medicine.
func (m *PrescriptionMutation) ClearPrescriptionmedicine() {
	m.clearedprescriptionmedicine = true
}

// PrescriptionmedicineCleared returns if the edge prescriptionmedicine was cleared.
func (m *PrescriptionMutation) PrescriptionmedicineCleared() bool {
	return m.clearedprescriptionmedicine
}

// PrescriptionmedicineID returns the prescriptionmedicine id in the mutation.
func (m *PrescriptionMutation) PrescriptionmedicineID() (id int, exists bool) {
	if m.prescriptionmedicine != nil {
		return *m.prescriptionmedicine, true
	}
	return
}

// PrescriptionmedicineIDs returns the prescriptionmedicine ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PrescriptionmedicineID instead. It exists only for internal usage by the builders.
func (m *PrescriptionMutation) PrescriptionmedicineIDs() (ids []int) {
	if id := m.prescriptionmedicine; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrescriptionmedicine reset all changes of the "prescriptionmedicine" edge.
func (m *PrescriptionMutation) ResetPrescriptionmedicine() {
	m.prescriptionmedicine = nil
	m.clearedprescriptionmedicine = false
}

// SetDispensemedicineID sets the dispensemedicine edge to DispenseMedicine by id.
func (m *PrescriptionMutation) SetDispensemedicineID(id int) {
	m.dispensemedicine = &id
}

// ClearDispensemedicine clears the dispensemedicine edge to DispenseMedicine.
func (m *PrescriptionMutation) ClearDispensemedicine() {
	m.cleareddispensemedicine = true
}

// DispensemedicineCleared returns if the edge dispensemedicine was cleared.
func (m *PrescriptionMutation) DispensemedicineCleared() bool {
	return m.cleareddispensemedicine
}

// DispensemedicineID returns the dispensemedicine id in the mutation.
func (m *PrescriptionMutation) DispensemedicineID() (id int, exists bool) {
	if m.dispensemedicine != nil {
		return *m.dispensemedicine, true
	}
	return
}

// DispensemedicineIDs returns the dispensemedicine ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DispensemedicineID instead. It exists only for internal usage by the builders.
func (m *PrescriptionMutation) DispensemedicineIDs() (ids []int) {
	if id := m.dispensemedicine; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDispensemedicine reset all changes of the "dispensemedicine" edge.
func (m *PrescriptionMutation) ResetDispensemedicine() {
	m.dispensemedicine = nil
	m.cleareddispensemedicine = false
}

// Op returns the operation name.
func (m *PrescriptionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Prescription).
func (m *PrescriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PrescriptionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.value != nil {
		fields = append(fields, prescription.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PrescriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case prescription.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PrescriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case prescription.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown Prescription field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PrescriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case prescription.FieldValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown Prescription field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PrescriptionMutation) AddedFields() []string {
	var fields []string
	if m.addvalue != nil {
		fields = append(fields, prescription.FieldValue)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PrescriptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case prescription.FieldValue:
		return m.AddedValue()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PrescriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case prescription.FieldValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	}
	return fmt.Errorf("unknown Prescription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PrescriptionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PrescriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PrescriptionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Prescription nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PrescriptionMutation) ResetField(name string) error {
	switch name {
	case prescription.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown Prescription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PrescriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.prescriptionpatient != nil {
		edges = append(edges, prescription.EdgePrescriptionpatient)
	}
	if m.prescriptiondoctor != nil {
		edges = append(edges, prescription.EdgePrescriptiondoctor)
	}
	if m.prescriptionmedicine != nil {
		edges = append(edges, prescription.EdgePrescriptionmedicine)
	}
	if m.dispensemedicine != nil {
		edges = append(edges, prescription.EdgeDispensemedicine)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PrescriptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case prescription.EdgePrescriptionpatient:
		if id := m.prescriptionpatient; id != nil {
			return []ent.Value{*id}
		}
	case prescription.EdgePrescriptiondoctor:
		if id := m.prescriptiondoctor; id != nil {
			return []ent.Value{*id}
		}
	case prescription.EdgePrescriptionmedicine:
		if id := m.prescriptionmedicine; id != nil {
			return []ent.Value{*id}
		}
	case prescription.EdgeDispensemedicine:
		if id := m.dispensemedicine; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PrescriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PrescriptionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PrescriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedprescriptionpatient {
		edges = append(edges, prescription.EdgePrescriptionpatient)
	}
	if m.clearedprescriptiondoctor {
		edges = append(edges, prescription.EdgePrescriptiondoctor)
	}
	if m.clearedprescriptionmedicine {
		edges = append(edges, prescription.EdgePrescriptionmedicine)
	}
	if m.cleareddispensemedicine {
		edges = append(edges, prescription.EdgeDispensemedicine)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PrescriptionMutation) EdgeCleared(name string) bool {
	switch name {
	case prescription.EdgePrescriptionpatient:
		return m.clearedprescriptionpatient
	case prescription.EdgePrescriptiondoctor:
		return m.clearedprescriptiondoctor
	case prescription.EdgePrescriptionmedicine:
		return m.clearedprescriptionmedicine
	case prescription.EdgeDispensemedicine:
		return m.cleareddispensemedicine
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PrescriptionMutation) ClearEdge(name string) error {
	switch name {
	case prescription.EdgePrescriptionpatient:
		m.ClearPrescriptionpatient()
		return nil
	case prescription.EdgePrescriptiondoctor:
		m.ClearPrescriptiondoctor()
		return nil
	case prescription.EdgePrescriptionmedicine:
		m.ClearPrescriptionmedicine()
		return nil
	case prescription.EdgeDispensemedicine:
		m.ClearDispensemedicine()
		return nil
	}
	return fmt.Errorf("unknown Prescription unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PrescriptionMutation) ResetEdge(name string) error {
	switch name {
	case prescription.EdgePrescriptionpatient:
		m.ResetPrescriptionpatient()
		return nil
	case prescription.EdgePrescriptiondoctor:
		m.ResetPrescriptiondoctor()
		return nil
	case prescription.EdgePrescriptionmedicine:
		m.ResetPrescriptionmedicine()
		return nil
	case prescription.EdgeDispensemedicine:
		m.ResetDispensemedicine()
		return nil
	}
	return fmt.Errorf("unknown Prescription edge %s", name)
}

// UnitOfMedicineMutation represents an operation that mutate the UnitOfMedicines
// nodes in the graph.
type UnitOfMedicineMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	clearedFields    map[string]struct{}
	_Medicine        map[int]struct{}
	removed_Medicine map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*UnitOfMedicine, error)
}

var _ ent.Mutation = (*UnitOfMedicineMutation)(nil)

// unitofmedicineOption allows to manage the mutation configuration using functional options.
type unitofmedicineOption func(*UnitOfMedicineMutation)

// newUnitOfMedicineMutation creates new mutation for $n.Name.
func newUnitOfMedicineMutation(c config, op Op, opts ...unitofmedicineOption) *UnitOfMedicineMutation {
	m := &UnitOfMedicineMutation{
		config:        c,
		op:            op,
		typ:           TypeUnitOfMedicine,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUnitOfMedicineID sets the id field of the mutation.
func withUnitOfMedicineID(id int) unitofmedicineOption {
	return func(m *UnitOfMedicineMutation) {
		var (
			err   error
			once  sync.Once
			value *UnitOfMedicine
		)
		m.oldValue = func(ctx context.Context) (*UnitOfMedicine, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UnitOfMedicine.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUnitOfMedicine sets the old UnitOfMedicine of the mutation.
func withUnitOfMedicine(node *UnitOfMedicine) unitofmedicineOption {
	return func(m *UnitOfMedicineMutation) {
		m.oldValue = func(context.Context) (*UnitOfMedicine, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UnitOfMedicineMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UnitOfMedicineMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UnitOfMedicineMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *UnitOfMedicineMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *UnitOfMedicineMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the UnitOfMedicine.
// If the UnitOfMedicine object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UnitOfMedicineMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *UnitOfMedicineMutation) ResetName() {
	m.name = nil
}

// AddMedicineIDs adds the Medicine edge to Medicine by ids.
func (m *UnitOfMedicineMutation) AddMedicineIDs(ids ...int) {
	if m._Medicine == nil {
		m._Medicine = make(map[int]struct{})
	}
	for i := range ids {
		m._Medicine[ids[i]] = struct{}{}
	}
}

// RemoveMedicineIDs removes the Medicine edge to Medicine by ids.
func (m *UnitOfMedicineMutation) RemoveMedicineIDs(ids ...int) {
	if m.removed_Medicine == nil {
		m.removed_Medicine = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_Medicine[ids[i]] = struct{}{}
	}
}

// RemovedMedicine returns the removed ids of Medicine.
func (m *UnitOfMedicineMutation) RemovedMedicineIDs() (ids []int) {
	for id := range m.removed_Medicine {
		ids = append(ids, id)
	}
	return
}

// MedicineIDs returns the Medicine ids in the mutation.
func (m *UnitOfMedicineMutation) MedicineIDs() (ids []int) {
	for id := range m._Medicine {
		ids = append(ids, id)
	}
	return
}

// ResetMedicine reset all changes of the "Medicine" edge.
func (m *UnitOfMedicineMutation) ResetMedicine() {
	m._Medicine = nil
	m.removed_Medicine = nil
}

// Op returns the operation name.
func (m *UnitOfMedicineMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UnitOfMedicine).
func (m *UnitOfMedicineMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UnitOfMedicineMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, unitofmedicine.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UnitOfMedicineMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case unitofmedicine.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UnitOfMedicineMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case unitofmedicine.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown UnitOfMedicine field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UnitOfMedicineMutation) SetField(name string, value ent.Value) error {
	switch name {
	case unitofmedicine.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown UnitOfMedicine field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UnitOfMedicineMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UnitOfMedicineMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UnitOfMedicineMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UnitOfMedicine numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UnitOfMedicineMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UnitOfMedicineMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UnitOfMedicineMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UnitOfMedicine nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UnitOfMedicineMutation) ResetField(name string) error {
	switch name {
	case unitofmedicine.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown UnitOfMedicine field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UnitOfMedicineMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Medicine != nil {
		edges = append(edges, unitofmedicine.EdgeMedicine)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UnitOfMedicineMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case unitofmedicine.EdgeMedicine:
		ids := make([]ent.Value, 0, len(m._Medicine))
		for id := range m._Medicine {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UnitOfMedicineMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_Medicine != nil {
		edges = append(edges, unitofmedicine.EdgeMedicine)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UnitOfMedicineMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case unitofmedicine.EdgeMedicine:
		ids := make([]ent.Value, 0, len(m.removed_Medicine))
		for id := range m.removed_Medicine {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UnitOfMedicineMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UnitOfMedicineMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UnitOfMedicineMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown UnitOfMedicine unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UnitOfMedicineMutation) ResetEdge(name string) error {
	switch name {
	case unitofmedicine.EdgeMedicine:
		m.ResetMedicine()
		return nil
	}
	return fmt.Errorf("unknown UnitOfMedicine edge %s", name)
}
